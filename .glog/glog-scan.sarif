{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-a72bfbb5-8bc9-4074-a6ab-2583490b14ab",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-8db9b51e-50ed-4935-8ff5-7fa053a700d6",
              "help": {
                "text": "",
                "markdown": "### Vulnerable/Compromised Hash Algorithm: MD5\n\nThe MD5 hash algorithm is considered cryptographically broken and unsuitable for further use due to its vulnerability to collision attacks. In C++ programming, using MD5 for hashing sensitive data can lead to security vulnerabilities, as attackers can generate different inputs that produce the same hash output, compromising data integrity and authenticity.\n\n### General Mitigation Advice\n\n1. **Avoid Using MD5**: Replace MD5 with a more secure hash function such as SHA-256 or SHA-3.\n2. **Use a Cryptographic Library**: Utilize well-established cryptographic libraries that provide secure implementations of hash functions.\n3. **Regularly Update Libraries**: Ensure that cryptographic libraries are up-to-date to benefit from the latest security patches and improvements.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD5 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"Sensitive data to hash\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 Hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- **OpenSSL**: Ensure that OpenSSL is installed and linked with your C++ project.\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten 2021](https://owasp.org/Top10/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-fe2c00ff-8b09-45c8-ad68-b1730baaebbf",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators can lead to vulnerabilities, especially when randomness is required for security purposes. The `rand()` function, which relies on `RAND_MAX`, is a common example of a non-cryptographic random number generator. It is predictable and not suitable for cryptographic purposes, such as generating keys, tokens, or any other security-sensitive data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographic random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which are more suitable for generating random numbers in a secure manner.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here's an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++11-compliant compiler.\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-1aac940e-1aef-421e-b0d3-23c00dceb6d9",
              "help": {
                "text": "",
                "markdown": "### Vulnerable/Compromised Hash Algorithm: MD5\n\nThe MD5 hash algorithm is considered cryptographically broken and unsuitable for further use due to its vulnerability to collision attacks. In C++ programming, using MD5 for hashing sensitive data can lead to security vulnerabilities, as attackers can generate different inputs that produce the same hash output, compromising data integrity and authenticity.\n\n### General Mitigation Advice\n\n1. **Avoid Using MD5**: Replace MD5 with a more secure hash function such as SHA-256 or SHA-3.\n2. **Use a Cryptographic Library**: Utilize well-established cryptographic libraries that provide secure implementations of hash functions.\n3. **Regularly Update Libraries**: Ensure that cryptographic libraries are up-to-date to benefit from the latest security patches and improvements.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD5 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"Sensitive data to hash\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 Hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- **OpenSSL**: Ensure that OpenSSL is installed and linked with your C++ project.\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten 2021](https://owasp.org/Top10/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-c522f791-aaf2-44a8-be48-4c51acaed2a5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-fdf3e3b7-b3a7-418b-9da7-334deafc4726",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-9dc91eba-aa08-4599-9bda-0d2629e0cf63",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-65b679af-23da-4fe2-890a-e542bc5b27b7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-82ff146b-c504-42f9-be94-14c5f07ad989",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-44403d0e-8870-4b75-ba7c-9ecf9eb5d8ba",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-a6ba7db3-afcd-4bcc-b656-2f102dcb6356",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability identified in the C function `memcpy` arises from the potential for buffer overflow, which can occur if the destination buffer is not large enough to accommodate the data being copied. This can lead to undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `strncpy` that provide additional safety checks.\n3. **Boundary Checks**: Implement boundary checks to prevent overflows.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows during development.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability in the provided code snippet, ensure that the destination buffer `aie_out` is properly sized before performing the `memcpy` operation. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <iostream> // Required for std::cerr\n\n// Assuming OutT is a defined type\ntypedef int OutT; // Example type definition\n\nvoid safe_memcpy(OutT* aie_out, const OutT* c_bo_map, size_t c_shape_0, size_t c_shape_1, size_t c_shape_2) {\n    size_t required_size = c_shape_0 * c_shape_1 * c_shape_2 * sizeof(OutT);\n    \n    // Assuming aie_out_size is the size of the aie_out buffer in bytes\n    size_t aie_out_size = /* size of aie_out buffer in bytes */;\n\n    if (aie_out_size >= required_size) {\n        memcpy((void *)aie_out, (void *)c_bo_map, required_size);\n    } else {\n        std::cerr << \"Buffer overflow risk: aie_out buffer is too small.\" << std::endl;\n        // Handle error appropriately\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For `memcpy`.\n- `<iostream>`: For error output using `std::cerr`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fe57fc6e-440d-41ef-8209-5ee99bc05618",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited in secure coding standards and should be avoided.\n\nIn this case, the `fopen` function is used, which can lead to vulnerabilities if not used correctly. The `fopen` function opens a file and returns a pointer to the file. If the file does not exist or cannot be found, the function returns a null pointer. This can lead to null pointer dereferencing if not handled correctly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen` such as `fopen_s` (in C11) or file stream objects in C++. These alternatives provide better error handling and are less prone to vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with `fopen_s` or file stream objects. Here is an example of how to use `fopen_s`:\n\n```cpp\nFILE* fp = NULL;\nerrno_t err = fopen_s(&fp, \"file.txt\", \"r\");\nif (err != 0) {\n    // Handle error\n} else {\n    // Use file\n    fclose(fp);\n}\n```\n\nAnd here is an example of how to use file stream objects:\n\n```cpp\n#include <fstream>\n\nstd::ifstream file(\"file.txt\");\nif (!file) {\n    // Handle error\n} else {\n    // Use file\n    file.close();\n}\n```\n\n## Library Dependencies\n\nThe code examples above require the following library dependencies:\n\n- `<stdio.h>` or `<cstdio>` for `fopen_s`\n- `<fstream>` for file stream objects\n\n## References\n"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-b3d7fa96-b3a2-4704-ab3c-28e2c76f7d32",
              "help": {
                "text": "",
                "markdown": "### Detected Issue with C Function: `memcpy`\n\nThe `memcpy` function in C/C++ is used to copy a block of memory from one location to another. The vulnerability arises when the size of the data being copied is not correctly specified, leading to buffer overflows or data corruption. In the provided code snippet, `memcpy(tmp, src, sizeof(float))`, the size of the data being copied is set to `sizeof(float)`, which may not match the actual size of the data intended to be copied. This can result in undefined behavior, including memory corruption, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` in C++ which provide better safety checks.\n3. **Boundary Checks**: Always perform boundary checks before copying data to prevent overflows.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the size parameter in `memcpy` accurately reflects the amount of data you intend to copy. Here's a corrected version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n\nvoid safeCopy(float* tmp, const float* src, size_t numElements) {\n    // Ensure that tmp has enough space to hold numElements\n    memcpy(tmp, src, numElements * sizeof(float));\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nThese resources provide further information on secure coding practices and common vulnerabilities related to memory operations."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-48a3cceb-d1c3-4fc9-9422-0efba0e73ad8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy((void *)a_bo_map, (void *)a, a_size)` can lead to several issues if not properly handled:\n\n1. **Buffer Overflow**: If `a_size` is larger than the destination buffer `a_bo_map`, it can cause a buffer overflow, leading to potential data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n2. **Null Pointer Dereference**: If either `a_bo_map` or `a` is a null pointer, calling `memcpy` will result in undefined behavior, potentially crashing the program.\n\n3. **Type Safety**: Casting to `(void *)` removes type safety, which can lead to incorrect assumptions about the data being copied.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the size of the destination buffer is at least as large as `a_size` before calling `memcpy`.\n\n2. **Null Checks**: Validate that both source and destination pointers are not null before performing the copy operation.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are possible.\n\n4. **Type Safety**: Avoid unnecessary casting to `(void *)` to maintain type safety.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for std::memcpy\n#include <algorithm> // Required for std::copy\n#include <iostream> // Required for std::cout\n\nvoid safe_memcpy(char* a_bo_map, const char* a, size_t a_size, size_t a_bo_map_size) {\n    if (a_bo_map == nullptr || a == nullptr) {\n        std::cerr << \"Null pointer detected!\" << std::endl;\n        return;\n    }\n\n    if (a_size > a_bo_map_size) {\n        std::cerr << \"Buffer overflow risk detected!\" << std::endl;\n        return;\n    }\n\n    std::copy(a, a + a_size, a_bo_map);\n}\n\nint main() {\n    const size_t buffer_size = 100;\n    char destination[buffer_size];\n    const char source[] = \"Hello, World!\";\n    size_t source_size = sizeof(source);\n\n    safe_memcpy(destination, source, source_size, buffer_size);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `std::memcpy`.\n- `<algorithm>`: Required for `std::copy`.\n- `<iostream>`: Required for `std::cout` and error messages.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f3988b86-4aa5-43a6-b228-f3104e0bdcdb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows, data corruption, or undefined behavior. This vulnerability typically occurs when the destination buffer is not large enough to hold the data being copied, or when the source and destination buffers overlap.\n\n### General Mitigation Advice\n\n1. **Ensure Buffer Size**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` if there is a possibility of overlapping buffers.\n3. **Boundary Checks**: Implement boundary checks to prevent buffer overflows.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability in the specific code snippet:\n\n```cpp\n// Original vulnerable code\nmemcpy((void *)aie_key, (void *)key, key_size);\n\n// Fixed code with boundary check\nif (key_size <= sizeof(aie_key)) {\n    memcpy((void *)aie_key, (void *)key, key_size);\n} else {\n    // Handle error: key_size is too large\n    // Log an error, throw an exception, or handle the error appropriately\n}\n```\n\n### Library Dependencies\n\nThe code example provided does not require any additional library dependencies beyond the standard C++ libraries.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-42389a24-0a29-4190-bb0e-f1c278a0b1f4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy((void *)a_bo_map, (void *)a, a_size)` can lead to several issues if not properly handled:\n\n1. **Buffer Overflow**: If `a_size` is larger than the destination buffer `a_bo_map`, it can cause a buffer overflow, leading to potential data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n2. **Null Pointer Dereference**: If either `a_bo_map` or `a` is a null pointer, calling `memcpy` will result in undefined behavior, potentially crashing the program.\n\n3. **Type Safety**: Casting to `(void *)` removes type safety, which can lead to incorrect assumptions about the data being copied.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the size of the destination buffer is at least as large as `a_size` before calling `memcpy`.\n\n2. **Null Checks**: Validate that both source and destination pointers are not null before performing the copy operation.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are possible.\n\n4. **Type Safety**: Avoid unnecessary casting to `(void *)` to maintain type safety.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for std::memcpy\n#include <algorithm> // Required for std::copy\n#include <iostream> // Required for std::cout\n\nvoid safe_memcpy(char* a_bo_map, const char* a, size_t a_size, size_t a_bo_map_size) {\n    if (a_bo_map == nullptr || a == nullptr) {\n        std::cerr << \"Null pointer detected!\" << std::endl;\n        return;\n    }\n\n    if (a_size > a_bo_map_size) {\n        std::cerr << \"Buffer overflow risk detected!\" << std::endl;\n        return;\n    }\n\n    std::copy(a, a + a_size, a_bo_map);\n}\n\nint main() {\n    const size_t buffer_size = 100;\n    char destination[buffer_size];\n    const char source[] = \"Hello, World!\";\n    size_t source_size = sizeof(source);\n\n    safe_memcpy(destination, source, source_size, buffer_size);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `std::memcpy`.\n- `<algorithm>`: Required for `std::copy`.\n- `<iostream>`: Required for `std::cout` and error messages.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9c2f51f3-26d5-4aa6-954b-93e8a6d810ed",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the size of the memory to be copied is not properly validated, which can lead to buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)aie_out, (void *)c_bo_map,\n       c_shape_[0] * c_shape_[1] * sizeof(OutT));\n```\n\nThe size of the memory being copied is calculated as `c_shape_[0] * c_shape_[1] * sizeof(OutT)`. If the calculated size exceeds the allocated size of the destination buffer `aie_out`, it can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n\n2. **Use Safer Functions**: Consider using safer alternatives to `memcpy`, such as `memmove` or `std::copy`, which provide additional safety checks.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assume aie_out_size is the size of the aie_out buffer\nsize_t aie_out_size = /* size of aie_out buffer */;\n\n// Calculate the size of the data to be copied\nsize_t data_size = c_shape_[0] * c_shape_[1] * sizeof(OutT);\n\n// Ensure the destination buffer is large enough\nif (data_size <= aie_out_size) {\n    memcpy((void *)aie_out, (void *)c_bo_map, data_size);\n} else {\n    // Handle error: destination buffer is too small\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function, if used for additional safety checks.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bc523b7e-3a2f-495e-8d57-a2fd52e1d3b6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++, which can lead to buffer overflow if not used carefully. The function call:\n\n```cpp\nmemcpy((void *)aie_msk, (void *)msk, msk_size);\n```\n\nis potentially dangerous if `msk_size` is larger than the allocated size of `aie_msk`. This can result in overwriting adjacent memory, leading to undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `std::copy` or `std::memmove` if overlapping memory areas are possible.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows.\n4. **Code Reviews**: Regularly perform code reviews to catch unsafe memory operations.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow, ensure that the size of the destination buffer is checked before performing the copy operation. Here is a safer version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\nvoid safe_memcpy(void* dest, const void* src, size_t dest_size, size_t src_size) {\n    size_t copy_size = std::min(dest_size, src_size);\n    memcpy(dest, src, copy_size);\n}\n\n// Usage\nsize_t aie_msk_size = /* size of aie_msk */;\nsize_t msk_size = /* size of msk */;\nsafe_memcpy((void *)aie_msk, (void *)msk, aie_msk_size, msk_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For `memcpy`.\n- `<algorithm>`: For `std::min`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f2f0f9c7-3eac-4854-9c15-1086db84a132",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the C function `memcpy` arises when there is a mismatch between the size of the source and destination buffers, leading to potential buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution. In the given code snippet:\n\n```cpp\nmemcpy((void *)aie_val, (void *)val, val_size);\n```\n\nThe function call copies `val_size` bytes from the source buffer `val` to the destination buffer `aie_val`. If `val_size` exceeds the size of the destination buffer `aie_val`, it can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` in C++ which provide better safety checks.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows.\n4. **Boundary Checks**: Implement boundary checks before performing memory operations.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\nvoid safe_memcpy(void* dest, size_t dest_size, const void* src, size_t src_size) {\n    size_t copy_size = std::min(dest_size, src_size);\n    memcpy(dest, src, copy_size);\n}\n\n// Usage\nsafe_memcpy((void *)aie_val, aie_val_size, (void *)val, val_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ce79fb7e-4fa9-4f2c-9ada-fbe9eb016267",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, leading to potential buffer overflows, data corruption, or undefined behavior. In the provided code snippet, `memcpy(&ret, &in_f, sizeof(in_f))`, the vulnerability may occur if the destination buffer `ret` is not large enough to hold the data being copied from `in_f`. This can result in overwriting adjacent memory, causing security vulnerabilities such as data leaks or application crashes.\n\n### General Mitigation Advice\n\n1. **Ensure Buffer Size**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if applicable, which provide better type safety and can handle overlapping memory regions.\n3. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory-related issues in your code.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer `ret` is appropriately sized. Here is an example of how you might adjust the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <iostream>\n\nint main() {\n    float in_f = 3.14f;\n    float ret; // Ensure ret is the same type and size as in_f\n\n    // Use memcpy safely\n    memcpy(&ret, &in_f, sizeof(ret)); // Ensure the size matches the destination buffer\n\n    std::cout << \"Copied value: \" << ret << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: Provides the `memcpy` function.\n- `<iostream>`: Used for input and output operations.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6c6fb64f-b671-471c-bffc-c3dbde91d9f3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the size of the memory to be copied is not properly validated, which can lead to buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)aie_out, (void *)c_bo_map,\n       c_shape_[0] * c_shape_[1] * sizeof(OutT));\n```\n\nThe size of the memory being copied is calculated as `c_shape_[0] * c_shape_[1] * sizeof(OutT)`. If the calculated size exceeds the allocated size of the destination buffer `aie_out`, it can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n\n2. **Use Safer Functions**: Consider using safer alternatives to `memcpy`, such as `memmove` or `std::copy`, which provide additional safety checks.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assume aie_out_size is the size of the aie_out buffer\nsize_t aie_out_size = /* size of aie_out buffer */;\n\n// Calculate the size of the data to be copied\nsize_t data_size = c_shape_[0] * c_shape_[1] * sizeof(OutT);\n\n// Ensure the destination buffer is large enough\nif (data_size <= aie_out_size) {\n    memcpy((void *)aie_out, (void *)c_bo_map, data_size);\n} else {\n    // Handle error: destination buffer is too small\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function, if used for additional safety checks.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ff4b5915-dc03-4c11-a1cc-56dbd46ff64a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows. This can occur when the size of the data being copied exceeds the size of the destination buffer. In the provided code snippet, the vulnerability is due to the use of `src_shape.at(2)` as the size parameter, which may not accurately reflect the size of the destination buffer `dst_ptr`.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `std::copy` or `std::memmove` that provide better safety guarantees.\n3. **Bounds Checking**: Always perform bounds checking before copying data to prevent overflows.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the size of the data being copied does not exceed the size of the destination buffer. Here's a revised version of the code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm> // for std::min\n\nvoid safe_memcpy(void* dst_ptr, const void* src_ptr, size_t dst_size, size_t src_size) {\n    size_t copy_size = std::min(dst_size, src_size);\n    std::memcpy(dst_ptr, src_ptr, copy_size);\n}\n\nint main() {\n    std::vector<int> src_shape = {10, 20, 30}; // Example source shape\n    size_t dst_size = 30; // Example destination buffer size\n    int dst[30]; // Destination buffer\n    int src[30]; // Source buffer\n\n    // Ensure the size to copy does not exceed the destination buffer size\n    safe_memcpy(dst, src, dst_size, src_shape.at(2));\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<iostream>`: For input and output operations.\n- `<vector>`: For using the `std::vector` container.\n- `<algorithm>`: For using the `std::min` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8b3eeb44-f55f-4589-b56e-c44057d8b5d6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy((void *)a_bo_map, (void *)a, a_size)` can lead to several issues if not properly handled:\n\n1. **Buffer Overflow**: If `a_size` is larger than the destination buffer `a_bo_map`, it can cause a buffer overflow, leading to potential data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n2. **Null Pointer Dereference**: If either `a_bo_map` or `a` is a null pointer, calling `memcpy` will result in undefined behavior, potentially crashing the program.\n\n3. **Type Safety**: Casting to `(void *)` removes type safety, which can lead to incorrect assumptions about the data being copied.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the size of the destination buffer is at least as large as `a_size` before calling `memcpy`.\n\n2. **Null Checks**: Validate that both source and destination pointers are not null before performing the copy operation.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are possible.\n\n4. **Type Safety**: Avoid unnecessary casting to `(void *)` to maintain type safety.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for std::memcpy\n#include <algorithm> // Required for std::copy\n#include <iostream> // Required for std::cout\n\nvoid safe_memcpy(char* a_bo_map, const char* a, size_t a_size, size_t a_bo_map_size) {\n    if (a_bo_map == nullptr || a == nullptr) {\n        std::cerr << \"Null pointer detected!\" << std::endl;\n        return;\n    }\n\n    if (a_size > a_bo_map_size) {\n        std::cerr << \"Buffer overflow risk detected!\" << std::endl;\n        return;\n    }\n\n    std::copy(a, a + a_size, a_bo_map);\n}\n\nint main() {\n    const size_t buffer_size = 100;\n    char destination[buffer_size];\n    const char source[] = \"Hello, World!\";\n    size_t source_size = sizeof(source);\n\n    safe_memcpy(destination, source, source_size, buffer_size);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `std::memcpy`.\n- `<algorithm>`: Required for `std::copy`.\n- `<iostream>`: Required for `std::cout` and error messages.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-307dc982-4a05-4c6d-86f8-a3ac1cdef52a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows, data corruption, or undefined behavior. This typically occurs when the source and destination buffers overlap, or when the size of the data to be copied exceeds the size of the destination buffer. In the provided code snippet, the use of `memcpy` could lead to such issues if `txn.data()` does not have enough space to accommodate the data being copied from `txn_ptr`.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `std::copy` or `std::memmove` which handle overlapping memory regions.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nReplace the `memcpy` call with `std::copy` or `std::memmove` to handle overlapping memory regions safely. Ensure that the destination buffer is adequately sized.\n\n```cpp\n#include <algorithm> // for std::copy\n#include <cstring>   // for std::memmove\n\n// Assuming txn is a container with a method data() returning a pointer\n// and txn_ptr is a pointer to the source data\nstd::memmove((void *)txn.data(), (void *)txn_ptr, size); // Use std::memmove if overlap is possible\n\n// Alternatively, use std::copy if no overlap is expected\nstd::copy((char *)txn_ptr, (char *)txn_ptr + size, (char *)txn.data());\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<algorithm>`: Provides the `std::copy` function.\n- `<cstring>`: Provides the `std::memmove` function.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d90b95f4-7155-48a9-8805-23c907adeba1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which can cause undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution. The specific issue here is that the size of the data being copied (`output_shape[1] * sizeof(AccT)`) may exceed the bounds of the destination buffer `c_acc`, leading to a potential buffer overflow.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved, as they provide better type safety and can prevent some common mistakes.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regular code reviews can help catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer `c_acc` is large enough to accommodate the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <algorithm> // For std::min\n#include <cstring>   // For std::memcpy\n\n// Assuming c_acc and c_map are properly defined and initialized\n// Assuming c_shape_ and kernel_z_shape_ are properly defined and initialized\n// Assuming output_shape is properly defined and initialized\n\nsize_t dest_size = c_shape_[1] - cb; // Calculate the remaining size in the destination buffer\nsize_t copy_size = output_shape[1] * sizeof(AccT); // Calculate the size of data to be copied\n\n// Ensure we do not exceed the destination buffer size\nsize_t safe_copy_size = std::min(dest_size, copy_size);\n\nstd::memcpy((void *)&c_acc[(i)*c_shape_[1] + cb],\n            (void *)&c_map[i * kernel_z_shape_[1]],\n            safe_copy_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<algorithm>`: For `std::min`\n- `<cstring>`: For `std::memcpy`\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-665d5a63-f2d3-4d8d-b0f3-c9df75c5e6be",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in the C++ code arises from the use of the `memcpy` function, which can lead to buffer overflow if the destination buffer is not large enough to hold the data being copied. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `std::copy` or `std::memmove` if overlapping memory areas are involved.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow in the given code, ensure that the destination buffer is adequately sized before performing the `memcpy` operation. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming a_map and a are properly defined and allocated\n// Assuming kernel_x_shape_ and a_shape_ are properly defined\n// Assuming input_1_size and a_dtype_size_ are properly defined\n\nsize_t destination_size = /* size of a_map buffer */;\nsize_t source_size = input_1_size * a_dtype_size_;\n\nif (i * kernel_x_shape_[1] + source_size <= destination_size) {\n    memcpy((void *)&a_map[i * kernel_x_shape_[1]], \n           (void *)&a[i * a_shape_[1]], \n           source_size);\n} else {\n    // Handle error: destination buffer is not large enough\n    // This could be logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For potential use of `std::min` or other safer alternatives.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-98a7cb69-3377-47c7-a34a-dc50cb79b9bb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which can cause undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       output_shape[1] * sizeof(AccT));\n```\n\nThe potential issue here is that if the destination buffer (`c_map[i * c_shape_[1]]`) is not large enough to hold the data being copied, a buffer overflow can occur. This can happen if `output_shape[1] * sizeof(AccT)` exceeds the size of the destination buffer.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow in the given code, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <algorithm> // For std::min\n\n// Assuming c_map is a valid pointer and c_shape_ and kernel_z_shape_ are valid arrays\nsize_t dest_size = c_shape_[1] * sizeof(AccT);\nsize_t src_size = kernel_z_shape_[1] * sizeof(AccT);\nsize_t copy_size = output_shape[1] * sizeof(AccT);\n\n// Ensure we do not copy more than the destination can hold\nsize_t safe_copy_size = std::min(dest_size, copy_size);\n\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       safe_copy_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<cstring>`: For `memcpy`.\n- `<algorithm>`: For `std::min`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-097a6eed-19b1-4a67-8c88-3ce9ee6423b3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which occur when the destination buffer is not large enough to hold the data being copied. This can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy((void *)&c_acc[(ra + i) * c_shape_[1] + cb],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       output_shape[1] * sizeof(AccT));\n```\n\nThe vulnerability arises if `output_shape[1] * sizeof(AccT)` exceeds the size of the destination buffer `&c_acc[(ra + i) * c_shape_[1] + cb]`. This can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. Perform explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <algorithm> // For std::min\n\n// Assuming c_acc_size is the total size of the c_acc buffer\nsize_t c_acc_size = /* size of c_acc buffer */;\n\n// Calculate the number of bytes to copy\nsize_t bytes_to_copy = output_shape[1] * sizeof(AccT);\n\n// Calculate the starting index in the destination buffer\nsize_t dest_index = (ra + i) * c_shape_[1] + cb;\n\n// Ensure we do not exceed the destination buffer size\nif (dest_index + bytes_to_copy <= c_acc_size) {\n    memcpy((void *)&c_acc[dest_index],\n           (void *)&c_map[i * kernel_z_shape_[1]],\n           bytes_to_copy);\n} else {\n    // Handle error: destination buffer is too small\n    // This could be logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<algorithm>`: For using `std::min` in bounds checking.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8a9d2c56-775c-4daf-991c-a7131e6ab0ed",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which can cause undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       output_shape[1] * sizeof(AccT));\n```\n\nThe potential issue here is that if the destination buffer (`c_map[i * c_shape_[1]]`) is not large enough to hold the data being copied, a buffer overflow can occur. This can happen if `output_shape[1] * sizeof(AccT)` exceeds the size of the destination buffer.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow in the given code, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <algorithm> // For std::min\n\n// Assuming c_map is a valid pointer and c_shape_ and kernel_z_shape_ are valid arrays\nsize_t dest_size = c_shape_[1] * sizeof(AccT);\nsize_t src_size = kernel_z_shape_[1] * sizeof(AccT);\nsize_t copy_size = output_shape[1] * sizeof(AccT);\n\n// Ensure we do not copy more than the destination can hold\nsize_t safe_copy_size = std::min(dest_size, copy_size);\n\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       safe_copy_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<cstring>`: For `memcpy`.\n- `<algorithm>`: For `std::min`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6d0f855d-6fed-4dc2-89dd-d241b8f0f5eb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which can cause undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       output_shape[1] * sizeof(AccT));\n```\n\nThe potential issue here is that if the destination buffer (`c_map[i * c_shape_[1]]`) is not large enough to hold the data being copied, a buffer overflow can occur. This can happen if `output_shape[1] * sizeof(AccT)` exceeds the size of the destination buffer.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow in the given code, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <algorithm> // For std::min\n\n// Assuming c_map is a valid pointer and c_shape_ and kernel_z_shape_ are valid arrays\nsize_t dest_size = c_shape_[1] * sizeof(AccT);\nsize_t src_size = kernel_z_shape_[1] * sizeof(AccT);\nsize_t copy_size = output_shape[1] * sizeof(AccT);\n\n// Ensure we do not copy more than the destination can hold\nsize_t safe_copy_size = std::min(dest_size, copy_size);\n\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       safe_copy_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<cstring>`: For `memcpy`.\n- `<algorithm>`: For `std::min`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ec3eecc8-961e-4127-b9f1-2f568a29e5b3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which can cause undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       output_shape[1] * sizeof(AccT));\n```\n\nThe potential issue here is that if the destination buffer (`c_map[i * c_shape_[1]]`) is not large enough to hold the data being copied, a buffer overflow can occur. This can happen if `output_shape[1] * sizeof(AccT)` exceeds the size of the destination buffer.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow in the given code, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <algorithm> // For std::min\n\n// Assuming c_map is a valid pointer and c_shape_ and kernel_z_shape_ are valid arrays\nsize_t dest_size = c_shape_[1] * sizeof(AccT);\nsize_t src_size = kernel_z_shape_[1] * sizeof(AccT);\nsize_t copy_size = output_shape[1] * sizeof(AccT);\n\n// Ensure we do not copy more than the destination can hold\nsize_t safe_copy_size = std::min(dest_size, copy_size);\n\nmemcpy((void *)&c_map[i * c_shape_[1]],\n       (void *)&c_map[i * kernel_z_shape_[1]],\n       safe_copy_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<cstring>`: For `memcpy`.\n- `<algorithm>`: For `std::min`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f91f55a1-404c-4f5e-9589-1bd877838d9e",
              "help": {
                "text": "",
                "markdown": "### Detected Issue with C Function: `memcpy`\n\nThe `memcpy` function in C/C++ is used to copy a block of memory from one location to another. However, improper use of `memcpy` can lead to vulnerabilities such as buffer overflows, which can cause undefined behavior, crashes, or security vulnerabilities like arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]],\n       input_shape[1] * a_dtype_size_);\n```\n\nThe vulnerability arises if the destination buffer (`a_map`) is not large enough to hold the data being copied from the source buffer (`a`). This can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `std::copy` in C++ which provide better type safety and can handle overlapping memory regions.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow, ensure that the destination buffer is adequately sized before performing the `memcpy` operation. Here is a revised version of the code with added checks:\n\n```cpp\n#include <algorithm> // For std::min\n\n// Assuming a_map_size is the total size of the a_map buffer\nsize_t a_map_size = /* size of a_map buffer */;\n\n// Calculate the number of bytes to copy\nsize_t bytes_to_copy = input_shape[1] * a_dtype_size_;\n\n// Ensure we do not exceed the destination buffer size\nif ((i * kernel_x_shape_[1] + bytes_to_copy) <= a_map_size) {\n    memcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]], bytes_to_copy);\n} else {\n    // Handle error: destination buffer is too small\n    // This could be logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, ensure the following library is included:\n\n- `<algorithm>`: Required for using `std::min` if needed for additional safety checks.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-99e2d102-fb41-4637-a9b6-9793a25a373f",
              "help": {
                "text": "",
                "markdown": "### Detected Issue with C Function: `memcpy`\n\nThe `memcpy` function in C/C++ is used to copy a block of memory from one location to another. However, improper use of `memcpy` can lead to vulnerabilities such as buffer overflows, which can cause undefined behavior, crashes, or security vulnerabilities like arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]],\n       input_shape[1] * a_dtype_size_);\n```\n\nThe vulnerability arises if the destination buffer (`a_map`) is not large enough to hold the data being copied from the source buffer (`a`). This can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `std::copy` in C++ which provide better type safety and can handle overlapping memory regions.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow, ensure that the destination buffer is adequately sized before performing the `memcpy` operation. Here is a revised version of the code with added checks:\n\n```cpp\n#include <algorithm> // For std::min\n\n// Assuming a_map_size is the total size of the a_map buffer\nsize_t a_map_size = /* size of a_map buffer */;\n\n// Calculate the number of bytes to copy\nsize_t bytes_to_copy = input_shape[1] * a_dtype_size_;\n\n// Ensure we do not exceed the destination buffer size\nif ((i * kernel_x_shape_[1] + bytes_to_copy) <= a_map_size) {\n    memcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]], bytes_to_copy);\n} else {\n    // Handle error: destination buffer is too small\n    // This could be logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, ensure the following library is included:\n\n- `<algorithm>`: Required for using `std::min` if needed for additional safety checks.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ffd84a24-2789-4155-8df5-89cd43353783",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which occur when the destination buffer is not large enough to hold the data being copied. This can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the call to `memcpy` is:\n\n```cpp\nmemcpy(bo_map.data(), output_wts.data(), output_wts.size());\n```\n\nThe vulnerability here is that there is no check to ensure that the destination buffer `bo_map` is large enough to accommodate the data being copied from `output_wts`. If `output_wts.size()` is greater than the size of `bo_map`, a buffer overflow will occur.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the source data with the size of the destination buffer before performing the copy.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives to `memcpy`, such as `std::copy` or `std::copy_n`, which are part of the C++ Standard Library and provide bounds checking.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough before performing the copy. Here is a revised version of the code:\n\n```cpp\n#include <algorithm> // for std::copy_n\n#include <vector>\n\nstd::vector<char> bo_map; // Ensure this is properly sized\nstd::vector<char> output_wts; // Source data\n\n// Ensure bo_map is large enough\nif (bo_map.size() >= output_wts.size()) {\n    std::copy_n(output_wts.data(), output_wts.size(), bo_map.data());\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<algorithm>`: For `std::copy_n`.\n- `<vector>`: For `std::vector`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f0842269-75db-41bf-99df-d56fbe2d5ec2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function: `memcpy`\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows or memory corruption. This can occur if the destination buffer is not large enough to hold the data being copied from the source, or if the size parameter is incorrect. In the provided code snippet, the vulnerability is due to the use of `memcpy` without ensuring that the destination buffer `bo_map` is large enough to accommodate the data from `bo_vec`.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. Use safer alternatives like `std::copy` or `std::memmove` when possible.\n2. **Use Safer Functions**: Consider using functions that perform bounds checking, such as `std::copy` from the C++ Standard Library.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is properly sized and use `std::copy` for safer copying:\n\n```cpp\n#include <vector>\n#include <algorithm> // for std::copy\n\nstd::vector<char> bo_vec = /* initialize with data */;\nstd::vector<char> bo_map(bo_vec.size()); // Ensure bo_map is the same size as bo_vec\n\nstd::copy(bo_vec.begin(), bo_vec.end(), bo_map.begin());\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<vector>`: For using `std::vector`.\n- `<algorithm>`: For using `std::copy`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b549c765-d2d3-4ae9-91e8-5da7cf739e26",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which occur when the destination buffer is not large enough to hold the data being copied. This can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(rp_zp.data() + dst_index, zp.data() + src_index, N_ * sizeof(int8_t));\n```\n\nThe vulnerability may occur if the destination buffer (`rp_zp`) does not have enough space starting from `dst_index` to accommodate `N_ * sizeof(int8_t)` bytes. Similarly, if the source buffer (`zp`) does not have enough data starting from `src_index`, it can lead to reading out of bounds.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. Similarly, ensure that the source buffer has enough data to be copied.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` which provide better safety guarantees and are less prone to errors.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regular code reviews can help catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that both the source and destination buffers are adequately sized. Here is a revised version of the code using `std::copy`:\n\n```cpp\n#include <algorithm> // for std::copy\n#include <vector>\n#include <cstdint> // for int8_t\n\nvoid safeCopy(std::vector<int8_t>& rp_zp, std::vector<int8_t>& zp, size_t dst_index, size_t src_index, size_t N_) {\n    if (dst_index + N_ <= rp_zp.size() && src_index + N_ <= zp.size()) {\n        std::copy(zp.begin() + src_index, zp.begin() + src_index + N_, rp_zp.begin() + dst_index);\n    } else {\n        // Handle error: either log, throw an exception, or take other appropriate action\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library headers are required:\n\n- `<algorithm>`: For `std::copy`.\n- `<vector>`: For `std::vector`.\n- `<cstdint>`: For `int8_t`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/): A list of the top ten security risks for web applications, which includes buffer overflow vulnerabilities.\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/): A quick reference guide for secure coding practices.\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html): This CWE entry describes the classic buffer overflow vulnerability, which is relevant to the use of `memcpy` without proper bounds checking."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-577df5b3-a33a-499c-9fa7-384bf4b6cc27",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in the C++ code arises from the use of the `memcpy` function, which can lead to buffer overflows if not used carefully. The function call `memcpy(rp_scale.data() + dst_index, scale.data() + src_index, N_ * sizeof(float))` copies `N_ * sizeof(float)` bytes from the source to the destination. If `N_` is larger than the available space in either the source or destination buffer, it can result in a buffer overflow, leading to undefined behavior, potential data corruption, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the source and destination buffers are large enough to accommodate the number of bytes being copied.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::copy_n` which perform bounds checking.\n3. **Input Validation**: Validate all inputs that determine the size of the data being copied to ensure they are within expected ranges.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n### Source Code Fix Recommendation\n\nReplace the `memcpy` call with `std::copy_n` to ensure bounds checking:\n\n```cpp\n#include <algorithm> // for std::copy_n\n#include <vector>\n\nvoid safeCopy(std::vector<float>& rp_scale, std::vector<float>& scale, size_t dst_index, size_t src_index, size_t N_) {\n    if (dst_index + N_ <= rp_scale.size() && src_index + N_ <= scale.size()) {\n        std::copy_n(scale.begin() + src_index, N_, rp_scale.begin() + dst_index);\n    } else {\n        // Handle error: either log, throw an exception, or take corrective action\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<algorithm>`: Provides the `std::copy_n` function.\n- `<vector>`: Provides the `std::vector` container.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-733b1a3d-e6a0-4068-b79e-113efaece089",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question is related to the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which can cause undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy(&output_data[target_idx], &combined_data[combined_idx],\n                      combined_dims[3] * sizeof(uint16_t));\n```\n\nThe vulnerability arises if the size of the destination buffer (`output_data`) is not sufficient to hold the data being copied from the source buffer (`combined_data`). This can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` which provide better safety guarantees.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the size of the destination buffer is checked before performing the `memcpy` operation. Here is a fixed version of the code:\n\n```cpp\n#include <algorithm> // for std::min\n\n// Assuming output_data and combined_data are defined and initialized properly\nsize_t output_size = /* size of output_data */;\nsize_t copy_size = combined_dims[3] * sizeof(uint16_t);\n\nif (target_idx + copy_size <= output_size) {\n    memcpy(&output_data[target_idx], &combined_data[combined_idx], copy_size);\n} else {\n    // Handle error: destination buffer is not large enough\n    // This could be logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- `<algorithm>`: Required for `std::min` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f3b9fa7d-5e69-4d40-a3af-e9f3821116c3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in the C++ code arises from the use of the `memcpy` function, which can lead to buffer overflow if the destination buffer is not large enough to accommodate the data being copied. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `std::copy` or `std::memmove` if overlapping memory areas are involved.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer `combined_data` is large enough to accommodate the data being copied from `zp_int16`. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <cstdint>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n// Example function demonstrating the fix\nvoid safe_memcpy(std::vector<uint16_t>& combined_data, size_t base_offset,\n                 const std::vector<uint16_t>& zp_int16, size_t zp_base_offset, size_t zp_dim3) {\n    // Ensure the destination buffer is large enough\n    if (base_offset + zp_dim3 <= combined_data.size() && zp_base_offset + zp_dim3 <= zp_int16.size()) {\n        std::memcpy(&combined_data[base_offset], &zp_int16[zp_base_offset], zp_dim3 * sizeof(uint16_t));\n    } else {\n        std::cerr << \"Buffer overflow risk detected!\" << std::endl;\n    }\n}\n\nint main() {\n    // Example usage\n    std::vector<uint16_t> combined_data(100);\n    std::vector<uint16_t> zp_int16(50);\n    size_t base_offset = 10;\n    size_t zp_base_offset = 5;\n    size_t zp_dim3 = 20;\n\n    safe_memcpy(combined_data, base_offset, zp_int16, zp_base_offset, zp_dim3);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard C++ libraries:\n\n- `<cstdint>`: For fixed-width integer types.\n- `<cstring>`: For the `memcpy` function.\n- `<iostream>`: For input and output operations.\n- `<vector>`: For using the `std::vector` container.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-84ab3f33-99c3-4d6f-947c-aafd816b201c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question is related to the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the size of the memory to be copied exceeds the size of the destination buffer, leading to a buffer overflow. This can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. Perform explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code snippet:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming output_data and bias_bf16 are properly defined and initialized\n// Assuming target_idx, bias_idx, and bias_dims are properly defined and initialized\n\nsize_t max_copy_size = sizeof(output_data) - target_idx * sizeof(uint16_t);\nsize_t copy_size = std::min(bias_dims[3] * sizeof(uint16_t), max_copy_size);\n\nmemcpy(&output_data[target_idx], &bias_bf16[bias_idx], copy_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-157fa5ef-55f0-4a0d-9439-022a88fb231d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the C function `memcpy` arises when there is a mismatch between the size of the source and destination buffers, leading to potential buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution. In the given code snippet:\n\n```cpp\nmemcpy((void *)aie_val, (void *)val, val_size);\n```\n\nThe function call copies `val_size` bytes from the source buffer `val` to the destination buffer `aie_val`. If `val_size` exceeds the size of the destination buffer `aie_val`, it can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` in C++ which provide better safety checks.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows.\n4. **Boundary Checks**: Implement boundary checks before performing memory operations.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\nvoid safe_memcpy(void* dest, size_t dest_size, const void* src, size_t src_size) {\n    size_t copy_size = std::min(dest_size, src_size);\n    memcpy(dest, src, copy_size);\n}\n\n// Usage\nsafe_memcpy((void *)aie_val, aie_val_size, (void *)val, val_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-3ece60eb-c6df-48d2-b2f2-bee1f1284f7c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question is related to the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which occur when data is written beyond the boundaries of the allocated memory. This can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy(&combined_data[base_offset + wts_dim3 + zp_dim3],\n       &scale_int16[scale_base_offset],\n       scale_dim3 * sizeof(uint16_t));\n```\n\nThe vulnerability arises if the destination buffer `combined_data` does not have enough space to accommodate the data being copied from `scale_int16`. This can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` which provide better type safety and can handle overlapping memory regions.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer has enough space before performing the `memcpy` operation. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <cstdint>\n#include <cstring>\n#include <algorithm> // For std::min\n\n// Assume these are defined and initialized appropriately\nextern uint16_t* combined_data;\nextern uint16_t* scale_int16;\nextern size_t combined_data_size;\nextern size_t base_offset;\nextern size_t wts_dim3;\nextern size_t zp_dim3;\nextern size_t scale_base_offset;\nextern size_t scale_dim3;\n\nvoid safe_memcpy() {\n    size_t dest_offset = base_offset + wts_dim3 + zp_dim3;\n    size_t bytes_to_copy = scale_dim3 * sizeof(uint16_t);\n\n    // Ensure there is enough space in the destination buffer\n    if (dest_offset + bytes_to_copy <= combined_data_size * sizeof(uint16_t)) {\n        memcpy(&combined_data[dest_offset],\n               &scale_int16[scale_base_offset],\n               bytes_to_copy);\n    } else {\n        // Handle error: insufficient space in destination buffer\n        // This could be logging an error, throwing an exception, etc.\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard C++ libraries are required:\n\n- `<cstdint>`: For fixed-width integer types like `uint16_t`.\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For utility functions like `std::min`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a79fb372-135c-4c1f-92ec-f1cb7e0b13f5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows, data corruption, or undefined behavior. This vulnerability typically occurs when the destination buffer is not large enough to hold the data being copied, or when the source and destination buffers overlap.\n\n### General Mitigation Advice\n\n1. **Ensure Buffer Size**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` if there is a possibility of overlapping buffers.\n3. **Boundary Checks**: Implement boundary checks to prevent buffer overflows.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability in the specific code snippet:\n\n```cpp\n// Original vulnerable code\nmemcpy((void *)aie_key, (void *)key, key_size);\n\n// Fixed code with boundary check\nif (key_size <= sizeof(aie_key)) {\n    memcpy((void *)aie_key, (void *)key, key_size);\n} else {\n    // Handle error: key_size is too large\n    // Log an error, throw an exception, or handle the error appropriately\n}\n```\n\n### Library Dependencies\n\nThe code example provided does not require any additional library dependencies beyond the standard C++ libraries.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-75ee352f-bca1-4010-8641-b4abc7cc6700",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy((void *)a_bo_map, (void *)a, a_size)` can lead to several issues if not properly handled:\n\n1. **Buffer Overflow**: If `a_size` is larger than the destination buffer `a_bo_map`, it can cause a buffer overflow, leading to potential data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n2. **Null Pointer Dereference**: If either `a_bo_map` or `a` is a null pointer, calling `memcpy` will result in undefined behavior, potentially crashing the program.\n\n3. **Type Safety**: Casting to `(void *)` removes type safety, which can lead to incorrect assumptions about the data being copied.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the size of the destination buffer is at least as large as `a_size` before calling `memcpy`.\n\n2. **Null Checks**: Validate that both source and destination pointers are not null before performing the copy operation.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are possible.\n\n4. **Type Safety**: Avoid unnecessary casting to `(void *)` to maintain type safety.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for std::memcpy\n#include <algorithm> // Required for std::copy\n#include <iostream> // Required for std::cout\n\nvoid safe_memcpy(char* a_bo_map, const char* a, size_t a_size, size_t a_bo_map_size) {\n    if (a_bo_map == nullptr || a == nullptr) {\n        std::cerr << \"Null pointer detected!\" << std::endl;\n        return;\n    }\n\n    if (a_size > a_bo_map_size) {\n        std::cerr << \"Buffer overflow risk detected!\" << std::endl;\n        return;\n    }\n\n    std::copy(a, a + a_size, a_bo_map);\n}\n\nint main() {\n    const size_t buffer_size = 100;\n    char destination[buffer_size];\n    const char source[] = \"Hello, World!\";\n    size_t source_size = sizeof(source);\n\n    safe_memcpy(destination, source, source_size, buffer_size);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `std::memcpy`.\n- `<algorithm>`: Required for `std::copy`.\n- `<iostream>`: Required for `std::cout` and error messages.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5fca0e49-3ce6-48ed-b291-d5da596e9443",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the size of the memory to be copied is not properly validated, which can lead to buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)aie_out, (void *)c_bo_map,\n       c_shape_[0] * c_shape_[1] * sizeof(OutT));\n```\n\nThe size of the memory being copied is calculated as `c_shape_[0] * c_shape_[1] * sizeof(OutT)`. If the calculated size exceeds the allocated size of the destination buffer `aie_out`, it can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n\n2. **Use Safer Functions**: Consider using safer alternatives to `memcpy`, such as `memmove` or `std::copy`, which provide additional safety checks.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assume aie_out_size is the size of the aie_out buffer\nsize_t aie_out_size = /* size of aie_out buffer */;\n\n// Calculate the size of the data to be copied\nsize_t data_size = c_shape_[0] * c_shape_[1] * sizeof(OutT);\n\n// Ensure the destination buffer is large enough\nif (data_size <= aie_out_size) {\n    memcpy((void *)aie_out, (void *)c_bo_map, data_size);\n} else {\n    // Handle error: destination buffer is too small\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function, if used for additional safety checks.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-88477908-a88a-4594-acb7-4d366c95fc7c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The identified issue arises when the size of the source buffer (`c_bo_map`) is not properly validated against the destination buffer (`aie_out`). This can lead to buffer overflows, which may result in undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Always ensure that the destination buffer is large enough to hold the data being copied from the source buffer.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` if overlapping memory regions are involved, or higher-level abstractions that automatically manage buffer sizes.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the size of the destination buffer is checked before performing the `memcpy` operation. Here is a fixed version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <iostream> // Required for std::cerr\n\nvoid safe_memcpy(void* dest, const void* src, size_t dest_size, size_t src_size) {\n    if (src_size > dest_size) {\n        std::cerr << \"Error: Source size is greater than destination size. Aborting memcpy.\" << std::endl;\n        return;\n    }\n    memcpy(dest, src, src_size);\n}\n\nint main() {\n    // Example usage\n    char aie_out[100];\n    char c_bo_map[50];\n    size_t operand_size_in_bytes_ = sizeof(c_bo_map);\n\n    safe_memcpy(aie_out, c_bo_map, sizeof(aie_out), operand_size_in_bytes_);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for the `memcpy` function.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b4d8fa81-0472-4572-a734-cd37b4f98672",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which occur when the destination buffer is not large enough to hold the data being copied. This can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the vulnerability is due to the potential for `wts_dim3 * sizeof(uint16_t)` to exceed the bounds of the `combined_data` buffer starting at `base_offset`. If `combined_data` is not large enough to accommodate the data being copied, a buffer overflow will occur.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives such as `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer is large enough to hold the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <cstdint>\n#include <cstring>\n#include <algorithm> // For std::min\n\n// Assume combined_data and wts_int16 are properly defined and initialized\nvoid safe_memcpy(uint8_t* combined_data, size_t combined_data_size, \n                 const uint16_t* wts_int16, size_t wts_dim3, \n                 size_t base_offset, size_t wts_base_offset) {\n    size_t bytes_to_copy = wts_dim3 * sizeof(uint16_t);\n    if (base_offset + bytes_to_copy <= combined_data_size) {\n        memcpy(&combined_data[base_offset], &wts_int16[wts_base_offset], bytes_to_copy);\n    } else {\n        // Handle error: destination buffer is not large enough\n        // For example, log an error or throw an exception\n    }\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard C++ libraries:\n\n- `<cstdint>`: For fixed-width integer types like `uint8_t` and `uint16_t`.\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For utility functions like `std::min`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fa94e480-fb93-4e08-8a02-340573277a53",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows, data corruption, or undefined behavior. The `memcpy` function copies a specified number of bytes from a source to a destination buffer. If the destination buffer is not large enough to hold the copied data, it can result in a buffer overflow, which is a common security vulnerability.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)b_bo_map, (void *)b, mask_size_in_bytes_);\n```\n\nThe vulnerability may occur if `b_bo_map` does not have enough allocated memory to accommodate `mask_size_in_bytes_` bytes. This can lead to overwriting adjacent memory, causing potential security risks such as data corruption or execution of arbitrary code.\n\n### General Mitigation Advice\n\n1. **Ensure Buffer Size**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before performing the copy operation.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` if overlapping memory regions are involved, or higher-level abstractions that automatically manage buffer sizes.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that `b_bo_map` is properly allocated to hold at least `mask_size_in_bytes_` bytes before calling `memcpy`. Here is an example fix:\n\n```cpp\n// Assuming b_bo_map is a pointer to a dynamically allocated buffer\nsize_t buffer_size = mask_size_in_bytes_; // Define the required buffer size\n\n// Allocate memory for b_bo_map if not already allocated\nif (b_bo_map == nullptr) {\n    b_bo_map = malloc(buffer_size);\n    if (b_bo_map == nullptr) {\n        // Handle memory allocation failure\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// Ensure the buffer is large enough\nif (buffer_size >= mask_size_in_bytes_) {\n    memcpy((void *)b_bo_map, (void *)b, mask_size_in_bytes_);\n} else {\n    // Handle error: buffer is not large enough\n    fprintf(stderr, \"Buffer overflow risk: destination buffer is too small\\n\");\n    exit(EXIT_FAILURE);\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard C library headers:\n\n```cpp\n#include <cstdlib>  // For malloc, exit\n#include <cstdio>   // For fprintf, stderr\n#include <cstring>  // For memcpy\n```\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f39087f6-eed3-42db-b945-db8700554d35",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes_)` can lead to several issues if not handled properly, such as buffer overflows, which occur when the destination buffer is not large enough to hold the data being copied. This can result in memory corruption, crashes, or even arbitrary code execution, making it a critical security vulnerability.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer is adequately sized and use safer functions if possible. Here's a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming a_bo_map and a are properly defined and initialized\nvoid safe_memcpy(void* a_bo_map, const void* a, size_t operand_size_in_bytes_, size_t a_bo_map_size) {\n    // Ensure the destination buffer is large enough\n    size_t bytes_to_copy = std::min(operand_size_in_bytes_, a_bo_map_size);\n    memcpy(a_bo_map, a, bytes_to_copy);\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b9db5897-5bd8-41ee-abc2-4abc7e479596",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the size of the memory to be copied is not properly validated, which can lead to buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)aie_out, (void *)c_bo_map,\n       c_shape_[0] * c_shape_[1] * sizeof(OutT));\n```\n\nThe size of the memory being copied is calculated as `c_shape_[0] * c_shape_[1] * sizeof(OutT)`. If the calculated size exceeds the allocated size of the destination buffer `aie_out`, it can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n\n2. **Use Safer Functions**: Consider using safer alternatives to `memcpy`, such as `memmove` or `std::copy`, which provide additional safety checks.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assume aie_out_size is the size of the aie_out buffer\nsize_t aie_out_size = /* size of aie_out buffer */;\n\n// Calculate the size of the data to be copied\nsize_t data_size = c_shape_[0] * c_shape_[1] * sizeof(OutT);\n\n// Ensure the destination buffer is large enough\nif (data_size <= aie_out_size) {\n    memcpy((void *)aie_out, (void *)c_bo_map, data_size);\n} else {\n    // Handle error: destination buffer is too small\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function, if used for additional safety checks.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-eb19200d-77ed-4dea-a616-4b224457ad4a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy((void *)a_bo_map, (void *)a, a_size)` can lead to several issues if not properly handled:\n\n1. **Buffer Overflow**: If `a_size` is larger than the destination buffer `a_bo_map`, it can cause a buffer overflow, leading to potential data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n2. **Null Pointer Dereference**: If either `a_bo_map` or `a` is a null pointer, calling `memcpy` will result in undefined behavior, potentially crashing the program.\n\n3. **Type Safety**: Casting to `(void *)` removes type safety, which can lead to incorrect assumptions about the data being copied.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the size of the destination buffer is at least as large as `a_size` before calling `memcpy`.\n\n2. **Null Checks**: Validate that both source and destination pointers are not null before performing the copy operation.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are possible.\n\n4. **Type Safety**: Avoid unnecessary casting to `(void *)` to maintain type safety.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for std::memcpy\n#include <algorithm> // Required for std::copy\n#include <iostream> // Required for std::cout\n\nvoid safe_memcpy(char* a_bo_map, const char* a, size_t a_size, size_t a_bo_map_size) {\n    if (a_bo_map == nullptr || a == nullptr) {\n        std::cerr << \"Null pointer detected!\" << std::endl;\n        return;\n    }\n\n    if (a_size > a_bo_map_size) {\n        std::cerr << \"Buffer overflow risk detected!\" << std::endl;\n        return;\n    }\n\n    std::copy(a, a + a_size, a_bo_map);\n}\n\nint main() {\n    const size_t buffer_size = 100;\n    char destination[buffer_size];\n    const char source[] = \"Hello, World!\";\n    size_t source_size = sizeof(source);\n\n    safe_memcpy(destination, source, source_size, buffer_size);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `std::memcpy`.\n- `<algorithm>`: Required for `std::copy`.\n- `<iostream>`: Required for `std::cout` and error messages.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-72c62076-44e5-4a09-80dd-15b97b2f468a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `memcpy` function in C++ arises from improper handling of memory copying operations, which can lead to buffer overflows, data corruption, or undefined behavior. The specific issue with the function call `memcpy((void *)param_bo_map, (void *)param, param_size)` is that it does not ensure that the destination buffer `param_bo_map` is large enough to hold the data being copied from `param`. This can result in writing beyond the bounds of the destination buffer, potentially leading to security vulnerabilities such as arbitrary code execution or denial of service.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `std::copy` in C++ that provide better safety guarantees.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other memory-related issues in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer is adequately sized before performing the `memcpy` operation. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <iostream> // Required for std::cerr\n\nvoid safe_memcpy(void* dest, size_t dest_size, const void* src, size_t src_size) {\n    if (src_size > dest_size) {\n        std::cerr << \"Error: Source size is greater than destination size. Aborting copy operation.\" << std::endl;\n        return;\n    }\n    memcpy(dest, src, src_size);\n}\n\nint main() {\n    // Example usage\n    char param_bo_map[100]; // Destination buffer\n    char param[50]; // Source buffer\n    size_t param_size = sizeof(param);\n\n    safe_memcpy(param_bo_map, sizeof(param_bo_map), param, param_size);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for the `memcpy` function.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6967650f-7d52-4f9c-8de8-9784d6f6fd8f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows, data corruption, or undefined behavior. This vulnerability typically occurs when the destination buffer is not large enough to hold the data being copied, or when the source or destination pointers are invalid. In the provided code snippet, `memcpy(params.data(), kernel_params_, 64)`, the vulnerability may occur if `params` does not have at least 64 bytes of allocated space.\n\n### General Mitigation Advice\n\n1. **Ensure Buffer Size**: Always ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` which provide better type safety and can handle overlapping memory regions.\n3. **Boundary Checks**: Implement boundary checks to ensure that the source and destination pointers are valid and within the expected range.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory-related issues.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability in the given code snippet, ensure that `params` has enough space and use `std::copy` for safer copying:\n\n```cpp\n#include <algorithm> // for std::copy\n#include <vector>    // for std::vector\n\n// Assuming kernel_params_ is a pointer to the source data\nvoid safeCopy(std::vector<char>& params, const char* kernel_params_) {\n    if (params.size() < 64) {\n        // Resize the vector to ensure it has enough space\n        params.resize(64);\n    }\n    std::copy(kernel_params_, kernel_params_ + 64, params.begin());\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard C++ libraries are required:\n\n- `<algorithm>`: Provides the `std::copy` function.\n- `<vector>`: Provides the `std::vector` container.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-fcceabe5-5ac2-44c4-ac43-71911cdd17b3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy(kernel_params_, kernel_params.data, params_bytes)` is potentially unsafe because it does not perform bounds checking on the destination buffer `kernel_params_`. If `params_bytes` exceeds the size of `kernel_params_`, this can lead to a buffer overflow, which is a common security vulnerability. Buffer overflows can result in undefined behavior, including data corruption, crashes, and security breaches such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. Use safer alternatives like `std::copy` or `std::memmove` if applicable.\n2. **Use Safer Functions**: Consider using safer functions like `memcpy_s` if available, which include additional parameters for bounds checking.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the size of the destination buffer is checked before performing the copy operation. Here is a revised version of the code:\n\n```cpp\n#include <algorithm> // for std::copy\n#include <cstring>   // for std::memcpy\n\n// Assuming kernel_params_ is a pointer and kernel_params is a struct or class with a data member\nvoid safeMemcpy(char* kernel_params_, const char* kernel_params_data, size_t params_bytes, size_t kernel_params_size) {\n    if (params_bytes <= kernel_params_size) {\n        std::memcpy(kernel_params_, kernel_params_data, params_bytes);\n    } else {\n        // Handle error: buffer overflow risk\n        // This could be logging the error, throwing an exception, etc.\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<algorithm>`: For using `std::copy` if needed.\n- `<cstring>`: For using `std::memcpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-43424f90-4625-4884-901f-c9b5e8127e3d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows, data corruption, or undefined behavior. This typically occurs when the source and destination buffers overlap, or when the size of the data to be copied exceeds the size of the destination buffer. In the provided code snippet, the use of `memcpy` could lead to such issues if `txn.data()` does not have enough space to accommodate the data being copied from `txn_ptr`.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `std::copy` or `std::memmove` which handle overlapping memory regions.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nReplace the `memcpy` call with `std::copy` or `std::memmove` to handle overlapping memory regions safely. Ensure that the destination buffer is adequately sized.\n\n```cpp\n#include <algorithm> // for std::copy\n#include <cstring>   // for std::memmove\n\n// Assuming txn is a container with a method data() returning a pointer\n// and txn_ptr is a pointer to the source data\nstd::memmove((void *)txn.data(), (void *)txn_ptr, size); // Use std::memmove if overlap is possible\n\n// Alternatively, use std::copy if no overlap is expected\nstd::copy((char *)txn_ptr, (char *)txn_ptr + size, (char *)txn.data());\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<algorithm>`: Provides the `std::copy` function.\n- `<cstring>`: Provides the `std::memmove` function.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-792edf2f-d5d8-495e-9df5-dde3e4e0c24e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-131d7be7-d023-46c2-ab47-fd79180c342f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-11103575-c7d4-42ec-a045-ccad8a2458fa",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the size of the memory to be copied is not properly validated, which can lead to buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)aie_out, (void *)c_bo_map,\n       c_shape_[0] * c_shape_[1] * sizeof(OutT));\n```\n\nThe size of the memory being copied is calculated as `c_shape_[0] * c_shape_[1] * sizeof(OutT)`. If the calculated size exceeds the allocated size of the destination buffer `aie_out`, it can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n\n2. **Use Safer Functions**: Consider using safer alternatives to `memcpy`, such as `memmove` or `std::copy`, which provide additional safety checks.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assume aie_out_size is the size of the aie_out buffer\nsize_t aie_out_size = /* size of aie_out buffer */;\n\n// Calculate the size of the data to be copied\nsize_t data_size = c_shape_[0] * c_shape_[1] * sizeof(OutT);\n\n// Ensure the destination buffer is large enough\nif (data_size <= aie_out_size) {\n    memcpy((void *)aie_out, (void *)c_bo_map, data_size);\n} else {\n    // Handle error: destination buffer is too small\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function, if used for additional safety checks.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-77ac4e0c-2e35-464b-8463-d435e9684787",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy((void *)a_bo_map, (void *)a, a_size)` can lead to several issues if not properly handled:\n\n1. **Buffer Overflow**: If `a_size` is larger than the destination buffer `a_bo_map`, it can cause a buffer overflow, leading to potential data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n2. **Null Pointer Dereference**: If either `a_bo_map` or `a` is a null pointer, calling `memcpy` will result in undefined behavior, potentially crashing the program.\n\n3. **Type Safety**: Casting to `(void *)` removes type safety, which can lead to incorrect assumptions about the data being copied.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the size of the destination buffer is at least as large as `a_size` before calling `memcpy`.\n\n2. **Null Checks**: Validate that both source and destination pointers are not null before performing the copy operation.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are possible.\n\n4. **Type Safety**: Avoid unnecessary casting to `(void *)` to maintain type safety.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for std::memcpy\n#include <algorithm> // Required for std::copy\n#include <iostream> // Required for std::cout\n\nvoid safe_memcpy(char* a_bo_map, const char* a, size_t a_size, size_t a_bo_map_size) {\n    if (a_bo_map == nullptr || a == nullptr) {\n        std::cerr << \"Null pointer detected!\" << std::endl;\n        return;\n    }\n\n    if (a_size > a_bo_map_size) {\n        std::cerr << \"Buffer overflow risk detected!\" << std::endl;\n        return;\n    }\n\n    std::copy(a, a + a_size, a_bo_map);\n}\n\nint main() {\n    const size_t buffer_size = 100;\n    char destination[buffer_size];\n    const char source[] = \"Hello, World!\";\n    size_t source_size = sizeof(source);\n\n    safe_memcpy(destination, source, source_size, buffer_size);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `std::memcpy`.\n- `<algorithm>`: Required for `std::copy`.\n- `<iostream>`: Required for `std::cout` and error messages.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b186afab-c3a5-46d4-86d1-c17e8eaa45e7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-c447fcf9-745b-42d9-98f8-ceb79ea17e58",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-002590e0-ee72-4e8d-ae14-0551a80ed1c2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the size of the memory to be copied is not properly validated, which can lead to buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)aie_out, (void *)c_bo_map,\n       c_shape_[0] * c_shape_[1] * sizeof(OutT));\n```\n\nThe size of the memory being copied is calculated as `c_shape_[0] * c_shape_[1] * sizeof(OutT)`. If the calculated size exceeds the allocated size of the destination buffer `aie_out`, it can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n\n2. **Use Safer Functions**: Consider using safer alternatives to `memcpy`, such as `memmove` or `std::copy`, which provide additional safety checks.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assume aie_out_size is the size of the aie_out buffer\nsize_t aie_out_size = /* size of aie_out buffer */;\n\n// Calculate the size of the data to be copied\nsize_t data_size = c_shape_[0] * c_shape_[1] * sizeof(OutT);\n\n// Ensure the destination buffer is large enough\nif (data_size <= aie_out_size) {\n    memcpy((void *)aie_out, (void *)c_bo_map, data_size);\n} else {\n    // Handle error: destination buffer is too small\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function, if used for additional safety checks.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5f644c68-9341-42b9-93cd-d47ff0ddedc5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy((void *)a_bo_map, (void *)a, a_size)` can lead to several issues if not properly handled:\n\n1. **Buffer Overflow**: If `a_size` is larger than the destination buffer `a_bo_map`, it can cause a buffer overflow, leading to potential data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n2. **Null Pointer Dereference**: If either `a_bo_map` or `a` is a null pointer, calling `memcpy` will result in undefined behavior, potentially crashing the program.\n\n3. **Type Safety**: Casting to `(void *)` removes type safety, which can lead to incorrect assumptions about the data being copied.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the size of the destination buffer is at least as large as `a_size` before calling `memcpy`.\n\n2. **Null Checks**: Validate that both source and destination pointers are not null before performing the copy operation.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are possible.\n\n4. **Type Safety**: Avoid unnecessary casting to `(void *)` to maintain type safety.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for std::memcpy\n#include <algorithm> // Required for std::copy\n#include <iostream> // Required for std::cout\n\nvoid safe_memcpy(char* a_bo_map, const char* a, size_t a_size, size_t a_bo_map_size) {\n    if (a_bo_map == nullptr || a == nullptr) {\n        std::cerr << \"Null pointer detected!\" << std::endl;\n        return;\n    }\n\n    if (a_size > a_bo_map_size) {\n        std::cerr << \"Buffer overflow risk detected!\" << std::endl;\n        return;\n    }\n\n    std::copy(a, a + a_size, a_bo_map);\n}\n\nint main() {\n    const size_t buffer_size = 100;\n    char destination[buffer_size];\n    const char source[] = \"Hello, World!\";\n    size_t source_size = sizeof(source);\n\n    safe_memcpy(destination, source, source_size, buffer_size);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `std::memcpy`.\n- `<algorithm>`: Required for `std::copy`.\n- `<iostream>`: Required for `std::cout` and error messages.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4e1321e0-e9d2-4bd7-8cf5-8dfd2ed0785f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the C function `memcpy` arises from its potential to cause buffer overflows if the destination buffer is not large enough to accommodate the data being copied. In C++, this can lead to undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution. The specific issue with the code snippet `memcpy(out_array, const_vecs.at(0).data(), total_bytes)` is that it does not ensure that `out_array` has sufficient space to hold `total_bytes` of data, which can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `std::copy` or `std::memmove` which provide better safety guarantees.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the size of `out_array` is checked before performing the `memcpy` operation. Here is a revised version of the code:\n\n```cpp\n#include <vector>\n#include <cstring>\n#include <algorithm> // For std::min\n\nvoid safe_memcpy(std::vector<char>& out_array, const std::vector<std::vector<char>>& const_vecs, size_t total_bytes) {\n    if (const_vecs.empty() || const_vecs.at(0).size() < total_bytes) {\n        throw std::out_of_range(\"Source vector is too small.\");\n    }\n    if (out_array.size() < total_bytes) {\n        throw std::out_of_range(\"Destination array is too small.\");\n    }\n    std::copy(const_vecs.at(0).begin(), const_vecs.at(0).begin() + total_bytes, out_array.begin());\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard C++ libraries are required:\n\n- `<vector>`: For using `std::vector`.\n- `<cstring>`: For using `memcpy` (though replaced with `std::copy` in the fix).\n- `<algorithm>`: For using `std::copy`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-32a63d15-2fd7-45e8-8f7c-48fe8f5cdb1f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes_)` can lead to several issues if not handled properly, such as buffer overflows, which occur when the destination buffer is not large enough to hold the data being copied. This can result in memory corruption, crashes, or even arbitrary code execution, making it a critical security vulnerability.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer is adequately sized and use safer functions if possible. Here's a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming a_bo_map and a are properly defined and initialized\nvoid safe_memcpy(void* a_bo_map, const void* a, size_t operand_size_in_bytes_, size_t a_bo_map_size) {\n    // Ensure the destination buffer is large enough\n    size_t bytes_to_copy = std::min(operand_size_in_bytes_, a_bo_map_size);\n    memcpy(a_bo_map, a, bytes_to_copy);\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2237b812-5e0e-420f-8229-f769030866c9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The identified issue arises when the size of the source buffer (`c_bo_map`) is not properly validated against the destination buffer (`aie_out`). This can lead to buffer overflows, which may result in undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Always ensure that the destination buffer is large enough to hold the data being copied from the source buffer.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` if overlapping memory regions are involved, or higher-level abstractions that automatically manage buffer sizes.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the size of the destination buffer is checked before performing the `memcpy` operation. Here is a fixed version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <iostream> // Required for std::cerr\n\nvoid safe_memcpy(void* dest, const void* src, size_t dest_size, size_t src_size) {\n    if (src_size > dest_size) {\n        std::cerr << \"Error: Source size is greater than destination size. Aborting memcpy.\" << std::endl;\n        return;\n    }\n    memcpy(dest, src, src_size);\n}\n\nint main() {\n    // Example usage\n    char aie_out[100];\n    char c_bo_map[50];\n    size_t operand_size_in_bytes_ = sizeof(c_bo_map);\n\n    safe_memcpy(aie_out, c_bo_map, sizeof(aie_out), operand_size_in_bytes_);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for the `memcpy` function.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9195a6fd-ea53-4ec1-9294-90f2a21ec22b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-4bc45186-5282-4aa8-a105-430dd05cc079",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e5a2f3b9-8596-4fa8-a9c2-cfecd87082f2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1f8a4c81-14e6-41e3-8d98-5a6a239a694f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e2454a0b-20ca-4925-8c1a-ecc8c440f358",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited in secure coding standards and should be avoided.\n\nIn this case, the `fopen` function is used, which can lead to vulnerabilities if not used correctly. The `fopen` function opens a file and returns a pointer to the file. If the file does not exist or cannot be found, the function returns a null pointer. This can lead to null pointer dereferencing if not handled correctly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen` such as `fopen_s` (in C11) or file stream objects in C++. These alternatives provide better error handling and are less prone to vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with `fopen_s` or file stream objects. Here is an example of how to use `fopen_s`:\n\n```cpp\nFILE* fp = NULL;\nerrno_t err = fopen_s(&fp, \"file.txt\", \"r\");\nif (err != 0) {\n    // Handle error\n} else {\n    // Use file\n    fclose(fp);\n}\n```\n\nAnd here is an example of how to use file stream objects:\n\n```cpp\n#include <fstream>\n\nstd::ifstream file(\"file.txt\");\nif (!file) {\n    // Handle error\n} else {\n    // Use file\n    file.close();\n}\n```\n\n## Library Dependencies\n\nThe code examples above require the following library dependencies:\n\n- `<stdio.h>` or `<cstdio>` for `fopen_s`\n- `<fstream>` for file stream objects\n\n## References\n"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-8591619b-5364-436c-8e80-16b396f75e2f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-cfe712a0-ece1-49de-90f8-309255ad0938",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-25158d96-3118-4c4d-9f1c-0b299d40a951",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-af6e983e-f205-46a4-84c4-1e762206b493",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-74d687b5-d1a2-4cf4-90f3-9f4a5efefc8d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The specific line of code:\n\n```cpp\nmemcpy((void *)b_bo_map, (void *)b, trig_size_in_bytes_);\n```\n\ncan lead to several issues if not handled properly:\n\n1. **Buffer Overflow**: If `trig_size_in_bytes_` is larger than the destination buffer `b_bo_map`, it can lead to a buffer overflow, potentially overwriting adjacent memory and causing undefined behavior or security vulnerabilities.\n\n2. **Null Pointer Dereference**: If either `b_bo_map` or `b` is a null pointer, dereferencing them will lead to a crash or undefined behavior.\n\n3. **Type Safety**: Casting to `(void *)` can obscure the types involved, making it harder to ensure that the sizes and types are compatible.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before performing the copy.\n\n2. **Null Checks**: Validate that both source and destination pointers are not null before calling `memcpy`.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n4. **Type Safety**: Avoid unnecessary casting to `(void *)` and ensure that the types are compatible.\n\n### Source Code Fix Recommendation\n\nHere's a revised version of the code with added safety checks:\n\n```cpp\n#include <cstring>  // For std::memcpy\n#include <stdexcept> // For std::runtime_error\n\nvoid safe_memcpy(void* dest, const void* src, size_t dest_size, size_t count) {\n    if (dest == nullptr || src == nullptr) {\n        throw std::runtime_error(\"Null pointer passed to memcpy\");\n    }\n    if (count > dest_size) {\n        throw std::runtime_error(\"Buffer overflow detected\");\n    }\n    std::memcpy(dest, src, count);\n}\n\n// Usage\ntry {\n    safe_memcpy(b_bo_map, b, sizeof(b_bo_map), trig_size_in_bytes_);\n} catch (const std::runtime_error& e) {\n    // Handle error\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: Provides the `std::memcpy` function.\n- `<stdexcept>`: Provides the `std::runtime_error` class for error handling.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/): A list of the top ten security risks.\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/): A quick reference guide for secure coding practices.\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1770e82f-c3f6-4628-bda8-4918bf8a0756",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the size of the memory to be copied is not properly validated, which can lead to buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)aie_out, (void *)c_bo_map,\n       c_shape_[0] * c_shape_[1] * sizeof(OutT));\n```\n\nThe size of the memory being copied is calculated as `c_shape_[0] * c_shape_[1] * sizeof(OutT)`. If the calculated size exceeds the allocated size of the destination buffer `aie_out`, it can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n\n2. **Use Safer Functions**: Consider using safer alternatives to `memcpy`, such as `memmove` or `std::copy`, which provide additional safety checks.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assume aie_out_size is the size of the aie_out buffer\nsize_t aie_out_size = /* size of aie_out buffer */;\n\n// Calculate the size of the data to be copied\nsize_t data_size = c_shape_[0] * c_shape_[1] * sizeof(OutT);\n\n// Ensure the destination buffer is large enough\nif (data_size <= aie_out_size) {\n    memcpy((void *)aie_out, (void *)c_bo_map, data_size);\n} else {\n    // Handle error: destination buffer is too small\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function, if used for additional safety checks.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7ca4a441-6942-4997-931c-33456f9da4d1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy((void *)a_bo_map, (void *)a, a_size)` can lead to several issues if not properly handled:\n\n1. **Buffer Overflow**: If `a_size` is larger than the destination buffer `a_bo_map`, it can cause a buffer overflow, leading to potential data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n2. **Null Pointer Dereference**: If either `a_bo_map` or `a` is a null pointer, calling `memcpy` will result in undefined behavior, potentially crashing the program.\n\n3. **Type Safety**: Casting to `(void *)` removes type safety, which can lead to incorrect assumptions about the data being copied.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Ensure that the size of the destination buffer is at least as large as `a_size` before calling `memcpy`.\n\n2. **Null Checks**: Validate that both source and destination pointers are not null before performing the copy operation.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are possible.\n\n4. **Type Safety**: Avoid unnecessary casting to `(void *)` to maintain type safety.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for std::memcpy\n#include <algorithm> // Required for std::copy\n#include <iostream> // Required for std::cout\n\nvoid safe_memcpy(char* a_bo_map, const char* a, size_t a_size, size_t a_bo_map_size) {\n    if (a_bo_map == nullptr || a == nullptr) {\n        std::cerr << \"Null pointer detected!\" << std::endl;\n        return;\n    }\n\n    if (a_size > a_bo_map_size) {\n        std::cerr << \"Buffer overflow risk detected!\" << std::endl;\n        return;\n    }\n\n    std::copy(a, a + a_size, a_bo_map);\n}\n\nint main() {\n    const size_t buffer_size = 100;\n    char destination[buffer_size];\n    const char source[] = \"Hello, World!\";\n    size_t source_size = sizeof(source);\n\n    safe_memcpy(destination, source, source_size, buffer_size);\n\n    std::cout << \"Copied string: \" << destination << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `std::memcpy`.\n- `<algorithm>`: Required for `std::copy`.\n- `<iostream>`: Required for `std::cout` and error messages.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-434c4519-776c-4093-88b7-c8223dce7639",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, which can lead to buffer overflow issues if not used carefully. The function `memcpy((void *)aie_out, (void *)c_bo_map, operand_size_in_bytes)` copies `operand_size_in_bytes` bytes from the source buffer `c_bo_map` to the destination buffer `aie_out`. If `operand_size_in_bytes` exceeds the size of the destination buffer `aie_out`, it can result in a buffer overflow, potentially leading to undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` if overlapping memory areas are involved, or higher-level abstractions that automatically manage buffer sizes.\n\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in the code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the size of the destination buffer `aie_out` is checked against `operand_size_in_bytes` before performing the copy operation. Here is an example of how you might modify the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <iostream> // Required for std::cerr\n\n// Assume these are defined and initialized appropriately\nvoid* aie_out;\nvoid* c_bo_map;\nsize_t operand_size_in_bytes;\nsize_t aie_out_size; // Size of the destination buffer\n\nif (operand_size_in_bytes <= aie_out_size) {\n    memcpy((void *)aie_out, (void *)c_bo_map, operand_size_in_bytes);\n} else {\n    std::cerr << \"Error: Buffer overflow risk detected. Copy operation aborted.\" << std::endl;\n    // Handle error appropriately\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<iostream>`: For error output using `std::cerr`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c9d29fa5-3261-4df6-9fe8-22bf9d6a42db",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-11e3ced3-bdc7-4c5c-ba2b-673f17fcc7e4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-f8acb37b-510a-4cd7-beca-ce20a7a16b8b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-afcefff5-6d31-4a9a-877f-3d903b4d3b02",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-6bdab580-a758-49c2-8b97-242821d6d7d9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The specific issue arises when the source and destination buffers overlap, or when the size of the data to be copied exceeds the size of the destination buffer. This can lead to buffer overflows, data corruption, or undefined behavior, which are common security vulnerabilities in C++ programs.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the size of the data being copied does not exceed the size of the destination buffer.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` if there is a possibility of overlapping memory regions.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory-related issues.\n4. **Boundary Checks**: Implement boundary checks to ensure that buffer sizes are respected.\n5. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability in the code snippet:\n\n```cpp\nmemcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes);\n```\n\nConsider the following:\n\n1. **Ensure Buffer Sizes**: Verify that `a_bo_map` has enough space to accommodate `operand_size_in_bytes`.\n2. **Use `memmove`**: If there is a possibility of overlapping memory regions, use `memmove` instead of `memcpy`.\n\nRevised code using `memmove`:\n\n```cpp\n#include <cstring> // Required for memcpy and memmove\n\n// Ensure that a_bo_map has enough space\nif (a_bo_map_size >= operand_size_in_bytes) {\n    memmove((void *)a_bo_map, (void *)a, operand_size_in_bytes);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using `memcpy` and `memmove`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-6c5a30b0-a362-4c57-ae92-3d720ca74139",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, specifically in the line:\n\n```cpp\nmemcpy(&float16_vec, in, remainder * sizeof(uint16_t));\n```\n\nThis line of code is potentially vulnerable to buffer overflow if the size of the destination buffer `float16_vec` is not properly managed. Buffer overflow occurs when data is written beyond the boundaries of pre-allocated fixed-length buffers, which can lead to undefined behavior, including data corruption, crashes, and security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Validate Input Size**: Ensure that the size of the input data does not exceed the size of the destination buffer.\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `std::copy` in C++ which provide better safety checks.\n3. **Boundary Checks**: Always perform boundary checks before copying data to ensure that the destination buffer is large enough to hold the data being copied.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added boundary checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming float16_vec is an array of uint16_t\nuint16_t float16_vec[BUFFER_SIZE]; // Define BUFFER_SIZE appropriately\nconst uint16_t* in; // Input data\nsize_t remainder; // Number of elements to copy\n\n// Ensure that we do not copy more than the buffer can hold\nsize_t max_elements = BUFFER_SIZE / sizeof(uint16_t);\nsize_t elements_to_copy = std::min(remainder, max_elements);\n\nmemcpy(&float16_vec, in, elements_to_copy * sizeof(uint16_t));\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following libraries are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b4af3b7c-9dec-454d-bc90-fa65615b6436",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, which can lead to buffer overflow if not used carefully. The specific issue is with the line:\n\n```cpp\nmemcpy(out, &float16_vec, remainder * sizeof(uint16_t));\n```\n\nThis line copies data from `float16_vec` to `out` using `memcpy`. If `out` does not have enough allocated space to accommodate `remainder * sizeof(uint16_t)` bytes, it can lead to a buffer overflow, potentially causing undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` if overlapping memory regions are possible, or higher-level abstractions that automatically manage buffer sizes.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows.\n4. **Code Reviews**: Regularly perform code reviews to catch unsafe memory operations.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow, ensure that the destination buffer `out` is large enough to hold the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring>  // For memcpy\n#include <cstdint>  // For uint16_t\n#include <iostream> // For std::cerr\n\n// Assume out_size is the size of the out buffer in bytes\nvoid safe_memcpy(uint16_t* out, size_t out_size, const uint16_t* float16_vec, size_t remainder) {\n    size_t required_size = remainder * sizeof(uint16_t);\n    if (out_size < required_size) {\n        std::cerr << \"Buffer overflow risk: destination buffer is too small.\" << std::endl;\n        return; // Or handle the error as appropriate\n    }\n    memcpy(out, float16_vec, required_size);\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<cstdint>`: For fixed-width integer types like `uint16_t`.\n- `<iostream>`: For error output using `std::cerr`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-790e0f02-e8c8-4734-bf77-a8b0a5aa9dd7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, which can lead to buffer overflow issues if not used carefully. The specific line of code:\n\n```cpp\nmemcpy(&bfloat16_vec, in, remainder * sizeof(uint16_t));\n```\n\nindicates that data is being copied from the source `in` to the destination `bfloat16_vec`. If the size of the data being copied (`remainder * sizeof(uint16_t)`) exceeds the size of the destination buffer, it can result in a buffer overflow, leading to potential security vulnerabilities such as data corruption, crashes, or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the size of the source data does not exceed the size of the destination buffer.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` in C++ which provide better safety checks.\n3. **Boundary Checks**: Implement boundary checks before performing memory operations to ensure that buffer overflows do not occur.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow, ensure that the destination buffer is large enough to hold the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming bfloat16_vec and in are defined and initialized properly\n// Define the size of the destination buffer\nconst size_t bfloat16_vec_size = /* size of bfloat16_vec in bytes */;\n\n// Calculate the number of bytes to copy\nsize_t bytes_to_copy = remainder * sizeof(uint16_t);\n\n// Ensure we do not exceed the destination buffer size\nbytes_to_copy = std::min(bytes_to_copy, bfloat16_vec_size);\n\nmemcpy(&bfloat16_vec, in, bytes_to_copy);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following libraries are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-bd2a1887-5351-4d6f-bc8f-ecb7f5892d68",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators can lead to vulnerabilities, especially when randomness is required for security purposes. The `rand()` function, which relies on `RAND_MAX`, is a common example of a non-cryptographic random number generator. It is predictable and not suitable for cryptographic purposes, such as generating keys, tokens, or any other security-sensitive data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographic random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which are more suitable for generating random numbers in a secure manner.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here's an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++11-compliant compiler.\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-2b99122f-f021-471e-a25e-ba554f9cee04",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-d1191486-ad49-464b-9d13-be745e8b9fba",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, which can lead to buffer overflow issues if not used carefully. The specific line of code:\n\n```cpp\nmemcpy(&dst[2], src, sizeof(uint16_t));\n```\n\nindicates that data is being copied into the `dst` buffer starting at the third byte. If `dst` is not large enough to accommodate the data being copied, this can result in a buffer overflow, potentially leading to undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `std::copy` in C++ which provide better safety guarantees.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer is adequately sized before performing the `memcpy` operation. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <cstdint> // Required for uint16_t\n\nvoid safe_memcpy(uint8_t* dst, const uint8_t* src, size_t dst_size) {\n    if (dst_size >= 2 + sizeof(uint16_t)) {\n        memcpy(&dst[2], src, sizeof(uint16_t));\n    } else {\n        // Handle error: destination buffer is too small\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<cstdint>`: For fixed-width integer types like `uint16_t`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-79855bf1-d3b4-45fd-92b9-94281708cf4c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflows, which occur when the destination buffer is not large enough to hold the data being copied. This can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(out, &bf16_vec, remainder * sizeof(uint16_t));\n```\n\nThe vulnerability may occur if the `out` buffer is not large enough to accommodate `remainder * sizeof(uint16_t)` bytes. This can lead to a buffer overflow, potentially overwriting adjacent memory and causing unpredictable behavior.\n\n### General Mitigation Advice\n\n1. **Buffer Size Validation**: Always ensure that the destination buffer is large enough to hold the data being copied. Validate the size of the buffer before performing the copy operation.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved, as they provide better safety guarantees.\n\n3. **Bounds Checking**: Implement bounds checking to ensure that the source and destination buffers are within valid memory ranges.\n\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n5. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the `out` buffer is properly sized before calling `memcpy`. Here is an example of how you might modify the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assume out_size is the size of the out buffer in bytes\nsize_t out_size = /* size of the out buffer */;\n\n// Calculate the number of bytes to copy\nsize_t bytes_to_copy = remainder * sizeof(uint16_t);\n\n// Ensure we do not copy more than the buffer can hold\nbytes_to_copy = std::min(bytes_to_copy, out_size);\n\nmemcpy(out, &bf16_vec, bytes_to_copy);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-19f3b614-a39c-42f1-ba5f-3b1c9ded06df",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the size of the memory to be copied is not properly validated, which can lead to buffer overflows. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((void *)aie_out, (void *)c_bo_map,\n       c_shape_[0] * c_shape_[1] * sizeof(OutT));\n```\n\nThe size of the memory being copied is calculated as `c_shape_[0] * c_shape_[1] * sizeof(OutT)`. If the calculated size exceeds the allocated size of the destination buffer `aie_out`, it can lead to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the destination buffer with the size of the data to be copied.\n\n2. **Use Safer Functions**: Consider using safer alternatives to `memcpy`, such as `memmove` or `std::copy`, which provide additional safety checks.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assume aie_out_size is the size of the aie_out buffer\nsize_t aie_out_size = /* size of aie_out buffer */;\n\n// Calculate the size of the data to be copied\nsize_t data_size = c_shape_[0] * c_shape_[1] * sizeof(OutT);\n\n// Ensure the destination buffer is large enough\nif (data_size <= aie_out_size) {\n    memcpy((void *)aie_out, (void *)c_bo_map, data_size);\n} else {\n    // Handle error: destination buffer is too small\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function, if used for additional safety checks.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-1d3a03a9-4c0d-4b25-9d59-abb07cfb66db",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, which can lead to buffer overflow issues if not used carefully. The specific line of code:\n\n```cpp\nmemcpy(&bfloat16_vec, in, remainder * sizeof(uint16_t));\n```\n\nindicates that data is being copied from the source `in` to the destination `bfloat16_vec`. If the size of the data being copied (`remainder * sizeof(uint16_t)`) exceeds the size of the destination buffer, it can result in a buffer overflow, leading to potential security vulnerabilities such as data corruption, crashes, or arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Always ensure that the size of the source data does not exceed the size of the destination buffer.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` in C++ which provide better safety checks.\n3. **Boundary Checks**: Implement boundary checks before performing memory operations to ensure that buffer overflows do not occur.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow, ensure that the destination buffer is large enough to hold the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming bfloat16_vec and in are defined and initialized properly\n// Define the size of the destination buffer\nconst size_t bfloat16_vec_size = /* size of bfloat16_vec in bytes */;\n\n// Calculate the number of bytes to copy\nsize_t bytes_to_copy = remainder * sizeof(uint16_t);\n\n// Ensure we do not exceed the destination buffer size\nbytes_to_copy = std::min(bytes_to_copy, bfloat16_vec_size);\n\nmemcpy(&bfloat16_vec, in, bytes_to_copy);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following libraries are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-a72bfbb5-8bc9-4074-a6ab-2583490b14ab",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/lrn_matrix.hpp"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 15,
                  "endLine": 93,
                  "endColumn": 20,
                  "charOffset": 3140,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-8db9b51e-50ed-4935-8ff5-7fa053a700d6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fusion_rt/md5.h"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 6,
                  "endLine": 36,
                  "endColumn": 9,
                  "charOffset": 830,
                  "charLength": 3,
                  "snippet": {
                    "text": "MD5",
                    "rendered": {
                      "text": "MD5",
                      "markdown": "`MD5`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fusion_rt/md5.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 830,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "SHA256"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fusion_rt/md5.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 830,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "SHA512"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-fe2c00ff-8b09-45c8-ad68-b1730baaebbf",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/lrn_matrix.hpp"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 25,
                  "endLine": 93,
                  "endColumn": 33,
                  "charOffset": 3150,
                  "charLength": 8,
                  "snippet": {
                    "text": "RAND_MAX",
                    "rendered": {
                      "text": "RAND_MAX",
                      "markdown": "`RAND_MAX`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-1aac940e-1aef-421e-b0d3-23c00dceb6d9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fusion_rt/md5.h"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 2,
                  "endLine": 43,
                  "endColumn": 5,
                  "charOffset": 1002,
                  "charLength": 3,
                  "snippet": {
                    "text": "MD5",
                    "rendered": {
                      "text": "MD5",
                      "markdown": "`MD5`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fusion_rt/md5.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1002,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "SHA256"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/fusion_rt/md5.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1002,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "SHA512"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-c522f791-aaf2-44a8-be48-4c51acaed2a5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/lrn_matrix.hpp"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 22,
                  "endLine": 83,
                  "endColumn": 27,
                  "charOffset": 2867,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-fdf3e3b7-b3a7-418b-9da7-334deafc4726",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/lrn_matrix.hpp"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 22,
                  "endLine": 83,
                  "endColumn": 30,
                  "charOffset": 2867,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-9dc91eba-aa08-4599-9bda-0d2629e0cf63",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/lrn_matrix.hpp"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 38,
                  "endLine": 76,
                  "endColumn": 46,
                  "charOffset": 2640,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-65b679af-23da-4fe2-890a-e542bc5b27b7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/lrn_matrix.hpp"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 38,
                  "endLine": 76,
                  "endColumn": 43,
                  "charOffset": 2640,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-82ff146b-c504-42f9-be94-14c5f07ad989",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/lrn_matrix.hpp"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 39,
                  "endLine": 75,
                  "endColumn": 44,
                  "charOffset": 2571,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-44403d0e-8870-4b75-ba7c-9ecf9eb5d8ba",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/lrn_matrix.hpp"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 39,
                  "endLine": 75,
                  "endColumn": 47,
                  "charOffset": 2571,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-a6ba7db3-afcd-4bcc-b656-2f102dcb6356",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/nni_resize/nni_resize.cpp"
                },
                "region": {
                  "startLine": 418,
                  "startColumn": 2,
                  "endLine": 419,
                  "endColumn": 63,
                  "charOffset": 15158,
                  "charLength": 105,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * c_shape_[2] * sizeof(OutT)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * c_shape_[2] * sizeof(OutT)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * c_shape_[2] * sizeof(OutT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/nni_resize/nni_resize.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15158,
                        "charLength": 105
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map, \n         c_shape_[0] * c_shape_[1] * c_shape_[2] * sizeof(OutT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fe57fc6e-440d-41ef-8209-5ee99bc05618",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/fusion_rt/metastate_api.cpp"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 10,
                  "endLine": 101,
                  "endColumn": 15,
                  "charOffset": 3022,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b3d7fa96-b3a2-4704-ab3c-28e2c76f7d32",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhagprb/mhagprb.cpp"
                },
                "region": {
                  "startLine": 1210,
                  "startColumn": 7,
                  "endLine": 1210,
                  "endColumn": 37,
                  "charOffset": 45565,
                  "charLength": 30,
                  "snippet": {
                    "text": "memcpy(tmp, src, sizeof(float)",
                    "rendered": {
                      "text": "memcpy(tmp, src, sizeof(float)",
                      "markdown": "`memcpy(tmp, src, sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhagprb/mhagprb.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 45565,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tmp, <size of tmp>,  src,  sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-48a3cceb-d1c3-4fc9-9422-0efba0e73ad8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/nni_resize/nni_resize.cpp"
                },
                "region": {
                  "startLine": 376,
                  "startColumn": 2,
                  "endLine": 376,
                  "endColumn": 45,
                  "charOffset": 13532,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, a_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/nni_resize/nni_resize.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13532,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  a_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f3988b86-4aa5-43a6-b228-f3104e0bdcdb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhagprb/mhagprb.cpp"
                },
                "region": {
                  "startLine": 1035,
                  "startColumn": 2,
                  "endLine": 1035,
                  "endColumn": 48,
                  "charOffset": 38044,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy((void *)aie_key, (void *)key, key_size)",
                    "rendered": {
                      "text": "memcpy((void *)aie_key, (void *)key, key_size)",
                      "markdown": "`memcpy((void *)aie_key, (void *)key, key_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhagprb/mhagprb.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38044,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_key, <size of (void *)aie_key>,  (void *)key,  key_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-42389a24-0a29-4190-bb0e-f1c278a0b1f4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhagprb/mhagprb.cpp"
                },
                "region": {
                  "startLine": 1027,
                  "startColumn": 2,
                  "endLine": 1027,
                  "endColumn": 45,
                  "charOffset": 37608,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, a_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhagprb/mhagprb.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37608,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  a_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9c2f51f3-26d5-4aa6-954b-93e8a6d810ed",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhagprb/mhagprb.cpp"
                },
                "region": {
                  "startLine": 1086,
                  "startColumn": 2,
                  "endLine": 1087,
                  "endColumn": 49,
                  "charOffset": 40173,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhagprb/mhagprb.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 40173,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map, \n         c_shape_[0] * c_shape_[1] * sizeof(OutT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bc523b7e-3a2f-495e-8d57-a2fd52e1d3b6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhagprb/mhagprb.cpp"
                },
                "region": {
                  "startLine": 1039,
                  "startColumn": 2,
                  "endLine": 1039,
                  "endColumn": 48,
                  "charOffset": 38239,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy((void *)aie_msk, (void *)msk, msk_size)",
                    "rendered": {
                      "text": "memcpy((void *)aie_msk, (void *)msk, msk_size)",
                      "markdown": "`memcpy((void *)aie_msk, (void *)msk, msk_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhagprb/mhagprb.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38239,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_msk, <size of (void *)aie_msk>,  (void *)msk,  msk_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f2f0f9c7-3eac-4854-9c15-1086db84a132",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhagprb/mhagprb.cpp"
                },
                "region": {
                  "startLine": 1036,
                  "startColumn": 2,
                  "endLine": 1036,
                  "endColumn": 48,
                  "charOffset": 38094,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy((void *)aie_val, (void *)val, val_size)",
                    "rendered": {
                      "text": "memcpy((void *)aie_val, (void *)val, val_size)",
                      "markdown": "`memcpy((void *)aie_val, (void *)val, val_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhagprb/mhagprb.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 38094,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_val, <size of (void *)aie_val>,  (void *)val,  val_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ce79fb7e-4fa9-4f2c-9ada-fbe9eb016267",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhagprb/mhagprb.cpp"
                },
                "region": {
                  "startLine": 233,
                  "startColumn": 7,
                  "endLine": 233,
                  "endColumn": 39,
                  "charOffset": 8654,
                  "charLength": 32,
                  "snippet": {
                    "text": "memcpy(&ret, &in_f, sizeof(in_f)",
                    "rendered": {
                      "text": "memcpy(&ret, &in_f, sizeof(in_f)",
                      "markdown": "`memcpy(&ret, &in_f, sizeof(in_f)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhagprb/mhagprb.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8654,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&ret, <size of &ret>,  &in_f,  sizeof(in_f)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6c6fb64f-b671-471c-bffc-c3dbde91d9f3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ReduceSum/ReduceSum.cpp"
                },
                "region": {
                  "startLine": 392,
                  "startColumn": 2,
                  "endLine": 393,
                  "endColumn": 49,
                  "charOffset": 14375,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/ReduceSum/ReduceSum.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14375,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map, \n         c_shape_[0] * c_shape_[1] * sizeof(OutT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ff4b5915-dc03-4c11-a1cc-56dbd46ff64a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhagprb/mhagprb.cpp"
                },
                "region": {
                  "startLine": 350,
                  "startColumn": 6,
                  "endLine": 350,
                  "endColumn": 46,
                  "charOffset": 12795,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy(dst_ptr, src_ptr, src_shape.at(2)",
                    "rendered": {
                      "text": "memcpy(dst_ptr, src_ptr, src_shape.at(2)",
                      "markdown": "`memcpy(dst_ptr, src_ptr, src_shape.at(2)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhagprb/mhagprb.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12795,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_ptr, <size of dst_ptr>,  src_ptr,  src_shape.at(2)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8b3eeb44-f55f-4589-b56e-c44057d8b5d6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ReduceSum/ReduceSum.cpp"
                },
                "region": {
                  "startLine": 350,
                  "startColumn": 2,
                  "endLine": 350,
                  "endColumn": 45,
                  "charOffset": 12694,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, a_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/ReduceSum/ReduceSum.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12694,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  a_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-307dc982-4a05-4c6d-86f8-a3ac1cdef52a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/preemption/preemption.cpp"
                },
                "region": {
                  "startLine": 68,
                  "startColumn": 2,
                  "endLine": 68,
                  "endColumn": 51,
                  "charOffset": 2642,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy((void *)txn.data(), (void *)txn_ptr, size)",
                    "rendered": {
                      "text": "memcpy((void *)txn.data(), (void *)txn_ptr, size)",
                      "markdown": "`memcpy((void *)txn.data(), (void *)txn_ptr, size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/preemption/preemption.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2642,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)txn.data(), <size of (void *)txn.data()>,  (void *)txn_ptr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d90b95f4-7155-48a9-8805-23c907adeba1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 2482,
                  "startColumn": 6,
                  "endLine": 2484,
                  "endColumn": 43,
                  "charOffset": 95435,
                  "charLength": 141,
                  "snippet": {
                    "text": "memcpy((void *)&c_acc[(i)*c_shape_[1] + cb],\n             (void *)&c_map[i * kernel_z_shape_[1]],\n             output_shape[1] * sizeof(AccT)",
                    "rendered": {
                      "text": "memcpy((void *)&c_acc[(i)*c_shape_[1] + cb],\n             (void *)&c_map[i * kernel_z_shape_[1]],\n             output_shape[1] * sizeof(AccT)",
                      "markdown": "`memcpy((void *)&c_acc[(i)*c_shape_[1] + cb],\n             (void *)&c_map[i * kernel_z_shape_[1]],\n             output_shape[1] * sizeof(AccT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 95435,
                        "charLength": 141
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&c_acc[(i)*c_shape_[1] + cb], <size of (void *)&c_acc[(i)*c_shape_[1] + cb]>, \n             (void *)&c_map[i * kernel_z_shape_[1]], \n             output_shape[1] * sizeof(AccT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-665d5a63-f2d3-4d8d-b0f3-c9df75c5e6be",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 2406,
                  "startColumn": 4,
                  "endLine": 2407,
                  "endColumn": 40,
                  "charOffset": 92389,
                  "charLength": 116,
                  "snippet": {
                    "text": "memcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]],\n           input_1_size * a_dtype_size_)",
                    "rendered": {
                      "text": "memcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]],\n           input_1_size * a_dtype_size_)",
                      "markdown": "`memcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]],\n           input_1_size * a_dtype_size_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 92389,
                        "charLength": 116
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&a_map[i * kernel_x_shape_[1]], <size of (void *)&a_map[i * kernel_x_shape_[1]]>,  (void *)&a[i * a_shape_[1]], \n           input_1_size * a_dtype_size_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-98a7cb69-3377-47c7-a34a-dc50cb79b9bb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 2154,
                  "startColumn": 8,
                  "endLine": 2156,
                  "endColumn": 45,
                  "charOffset": 82896,
                  "charLength": 140,
                  "snippet": {
                    "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                    "rendered": {
                      "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                      "markdown": "`memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 82896,
                        "charLength": 140
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&c_map[i * c_shape_[1]], <size of (void *)&c_map[i * c_shape_[1]]>, \n               (void *)&c_map[i * kernel_z_shape_[1]], \n               output_shape[1] * sizeof(AccT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-097a6eed-19b1-4a67-8c88-3ce9ee6423b3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 2268,
                  "startColumn": 8,
                  "endLine": 2270,
                  "endColumn": 45,
                  "charOffset": 86937,
                  "charLength": 152,
                  "snippet": {
                    "text": "memcpy((void *)&c_acc[(ra + i) * c_shape_[1] + cb],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                    "rendered": {
                      "text": "memcpy((void *)&c_acc[(ra + i) * c_shape_[1] + cb],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                      "markdown": "`memcpy((void *)&c_acc[(ra + i) * c_shape_[1] + cb],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 86937,
                        "charLength": 152
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&c_acc[(ra + i) * c_shape_[1] + cb], <size of (void *)&c_acc[(ra + i) * c_shape_[1] + cb]>, \n               (void *)&c_map[i * kernel_z_shape_[1]], \n               output_shape[1] * sizeof(AccT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8a9d2c56-775c-4daf-991c-a7131e6ab0ed",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 2070,
                  "startColumn": 8,
                  "endLine": 2072,
                  "endColumn": 45,
                  "charOffset": 79759,
                  "charLength": 140,
                  "snippet": {
                    "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                    "rendered": {
                      "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                      "markdown": "`memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 79759,
                        "charLength": 140
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&c_map[i * c_shape_[1]], <size of (void *)&c_map[i * c_shape_[1]]>, \n               (void *)&c_map[i * kernel_z_shape_[1]], \n               output_shape[1] * sizeof(AccT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6d0f855d-6fed-4dc2-89dd-d241b8f0f5eb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 2027,
                  "startColumn": 8,
                  "endLine": 2029,
                  "endColumn": 45,
                  "charOffset": 78066,
                  "charLength": 140,
                  "snippet": {
                    "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                    "rendered": {
                      "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                      "markdown": "`memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 78066,
                        "charLength": 140
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&c_map[i * c_shape_[1]], <size of (void *)&c_map[i * c_shape_[1]]>, \n               (void *)&c_map[i * kernel_z_shape_[1]], \n               output_shape[1] * sizeof(AccT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ec3eecc8-961e-4127-b9f1-2f568a29e5b3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 1948,
                  "startColumn": 8,
                  "endLine": 1950,
                  "endColumn": 45,
                  "charOffset": 74555,
                  "charLength": 140,
                  "snippet": {
                    "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                    "rendered": {
                      "text": "memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)",
                      "markdown": "`memcpy((void *)&c_map[i * c_shape_[1]],\n               (void *)&c_map[i * kernel_z_shape_[1]],\n               output_shape[1] * sizeof(AccT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 74555,
                        "charLength": 140
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&c_map[i * c_shape_[1]], <size of (void *)&c_map[i * c_shape_[1]]>, \n               (void *)&c_map[i * kernel_z_shape_[1]], \n               output_shape[1] * sizeof(AccT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f91f55a1-404c-4f5e-9589-1bd877838d9e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 1812,
                  "startColumn": 4,
                  "endLine": 1813,
                  "endColumn": 42,
                  "charOffset": 69150,
                  "charLength": 118,
                  "snippet": {
                    "text": "memcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]],\n           input_shape[1] * a_dtype_size_)",
                    "rendered": {
                      "text": "memcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]],\n           input_shape[1] * a_dtype_size_)",
                      "markdown": "`memcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]],\n           input_shape[1] * a_dtype_size_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69150,
                        "charLength": 118
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&a_map[i * kernel_x_shape_[1]], <size of (void *)&a_map[i * kernel_x_shape_[1]]>,  (void *)&a[i * a_shape_[1]], \n           input_shape[1] * a_dtype_size_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-99e2d102-fb41-4637-a9b6-9793a25a373f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 1719,
                  "startColumn": 4,
                  "endLine": 1720,
                  "endColumn": 42,
                  "charOffset": 65641,
                  "charLength": 118,
                  "snippet": {
                    "text": "memcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]],\n           input_shape[1] * a_dtype_size_)",
                    "rendered": {
                      "text": "memcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]],\n           input_shape[1] * a_dtype_size_)",
                      "markdown": "`memcpy((void *)&a_map[i * kernel_x_shape_[1]], (void *)&a[i * a_shape_[1]],\n           input_shape[1] * a_dtype_size_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 65641,
                        "charLength": 118
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)&a_map[i * kernel_x_shape_[1]], <size of (void *)&a_map[i * kernel_x_shape_[1]]>,  (void *)&a[i * a_shape_[1]], \n           input_shape[1] * a_dtype_size_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ffd84a24-2789-4155-8df5-89cd43353783",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 743,
                  "startColumn": 7,
                  "endLine": 744,
                  "endColumn": 31,
                  "charOffset": 27624,
                  "charLength": 72,
                  "snippet": {
                    "text": "memcpy(bo_map.data(), output_wts.data(),\n              output_wts.size()",
                    "rendered": {
                      "text": "memcpy(bo_map.data(), output_wts.data(),\n              output_wts.size()",
                      "markdown": "`memcpy(bo_map.data(), output_wts.data(),\n              output_wts.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27624,
                        "charLength": 72
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bo_map.data(), <size of bo_map.data()>,  output_wts.data(), \n              output_wts.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f0842269-75db-41bf-99df-d56fbe2d5ec2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 1167,
                  "startColumn": 11,
                  "endLine": 1167,
                  "endColumn": 54,
                  "charOffset": 43989,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy(bo_map, bo_vec.data(), bo_vec.size()",
                    "rendered": {
                      "text": "memcpy(bo_map, bo_vec.data(), bo_vec.size()",
                      "markdown": "`memcpy(bo_map, bo_vec.data(), bo_vec.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43989,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bo_map, <size of bo_map>,  bo_vec.data(),  bo_vec.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b549c765-d2d3-4ae9-91e8-5da7cf739e26",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 560,
                  "startColumn": 11,
                  "endLine": 561,
                  "endColumn": 37,
                  "charOffset": 21019,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(rp_zp.data() + dst_index, zp.data() + src_index,\n                  N_ * sizeof(int8_t)",
                    "rendered": {
                      "text": "memcpy(rp_zp.data() + dst_index, zp.data() + src_index,\n                  N_ * sizeof(int8_t)",
                      "markdown": "`memcpy(rp_zp.data() + dst_index, zp.data() + src_index,\n                  N_ * sizeof(int8_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21019,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(rp_zp.data() + dst_index, <size of rp_zp.data() + dst_index>,  zp.data() + src_index, \n                  N_ * sizeof(int8_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-577df5b3-a33a-499c-9fa7-384bf4b6cc27",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 641,
                  "startColumn": 11,
                  "endLine": 642,
                  "endColumn": 36,
                  "charOffset": 23915,
                  "charLength": 98,
                  "snippet": {
                    "text": "memcpy(rp_scale.data() + dst_index, scale.data() + src_index,\n                  N_ * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(rp_scale.data() + dst_index, scale.data() + src_index,\n                  N_ * sizeof(float)",
                      "markdown": "`memcpy(rp_scale.data() + dst_index, scale.data() + src_index,\n                  N_ * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23915,
                        "charLength": 98
                      },
                      "insertedContent": {
                        "text": "memcpy_s(rp_scale.data() + dst_index, <size of rp_scale.data() + dst_index>,  scale.data() + src_index, \n                  N_ * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-733b1a3d-e6a0-4068-b79e-113efaece089",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 460,
                  "startColumn": 15,
                  "endLine": 461,
                  "endColumn": 57,
                  "charOffset": 17571,
                  "charLength": 120,
                  "snippet": {
                    "text": "memcpy(&output_data[target_idx], &combined_data[combined_idx],\n                      combined_dims[3] * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&output_data[target_idx], &combined_data[combined_idx],\n                      combined_dims[3] * sizeof(uint16_t)",
                      "markdown": "`memcpy(&output_data[target_idx], &combined_data[combined_idx],\n                      combined_dims[3] * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17571,
                        "charLength": 120
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&output_data[target_idx], <size of &output_data[target_idx]>,  &combined_data[combined_idx], \n                      combined_dims[3] * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f3b9fa7d-5e69-4d40-a3af-e9f3821116c3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 13,
                  "endLine": 332,
                  "endColumn": 73,
                  "charOffset": 12555,
                  "charLength": 120,
                  "snippet": {
                    "text": "memcpy(&combined_data[base_offset + wts_dim3],\n                    &zp_int16[zp_base_offset], zp_dim3 * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&combined_data[base_offset + wts_dim3],\n                    &zp_int16[zp_base_offset], zp_dim3 * sizeof(uint16_t)",
                      "markdown": "`memcpy(&combined_data[base_offset + wts_dim3],\n                    &zp_int16[zp_base_offset], zp_dim3 * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12555,
                        "charLength": 120
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&combined_data[base_offset + wts_dim3], <size of &combined_data[base_offset + wts_dim3]>, \n                    &zp_int16[zp_base_offset],  zp_dim3 * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-84ab3f33-99c3-4d6f-947c-aafd816b201c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 454,
                  "startColumn": 15,
                  "endLine": 455,
                  "endColumn": 53,
                  "charOffset": 17259,
                  "charLength": 108,
                  "snippet": {
                    "text": "memcpy(&output_data[target_idx], &bias_bf16[bias_idx],\n                      bias_dims[3] * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&output_data[target_idx], &bias_bf16[bias_idx],\n                      bias_dims[3] * sizeof(uint16_t)",
                      "markdown": "`memcpy(&output_data[target_idx], &bias_bf16[bias_idx],\n                      bias_dims[3] * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17259,
                        "charLength": 108
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&output_data[target_idx], <size of &output_data[target_idx]>,  &bias_bf16[bias_idx], \n                      bias_dims[3] * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-157fa5ef-55f0-4a0d-9439-022a88fb231d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhamzdk5/mhamzdk5.cpp"
                },
                "region": {
                  "startLine": 523,
                  "startColumn": 2,
                  "endLine": 523,
                  "endColumn": 48,
                  "charOffset": 19585,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy((void *)aie_val, (void *)val, val_size)",
                    "rendered": {
                      "text": "memcpy((void *)aie_val, (void *)val, val_size)",
                      "markdown": "`memcpy((void *)aie_val, (void *)val, val_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhamzdk5/mhamzdk5.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19585,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_val, <size of (void *)aie_val>,  (void *)val,  val_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3ece60eb-c6df-48d2-b2f2-bee1f1284f7c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 333,
                  "startColumn": 13,
                  "endLine": 335,
                  "endColumn": 49,
                  "charOffset": 12691,
                  "charLength": 159,
                  "snippet": {
                    "text": "memcpy(&combined_data[base_offset + wts_dim3 + zp_dim3],\n                    &scale_int16[scale_base_offset],\n                    scale_dim3 * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&combined_data[base_offset + wts_dim3 + zp_dim3],\n                    &scale_int16[scale_base_offset],\n                    scale_dim3 * sizeof(uint16_t)",
                      "markdown": "`memcpy(&combined_data[base_offset + wts_dim3 + zp_dim3],\n                    &scale_int16[scale_base_offset],\n                    scale_dim3 * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12691,
                        "charLength": 159
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&combined_data[base_offset + wts_dim3 + zp_dim3], <size of &combined_data[base_offset + wts_dim3 + zp_dim3]>, \n                    &scale_int16[scale_base_offset], \n                    scale_dim3 * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a79fb372-135c-4c1f-92ec-f1cb7e0b13f5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhamzdk5/mhamzdk5.cpp"
                },
                "region": {
                  "startLine": 522,
                  "startColumn": 2,
                  "endLine": 522,
                  "endColumn": 48,
                  "charOffset": 19535,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy((void *)aie_key, (void *)key, key_size)",
                    "rendered": {
                      "text": "memcpy((void *)aie_key, (void *)key, key_size)",
                      "markdown": "`memcpy((void *)aie_key, (void *)key, key_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhamzdk5/mhamzdk5.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19535,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_key, <size of (void *)aie_key>,  (void *)key,  key_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-75ee352f-bca1-4010-8641-b4abc7cc6700",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhamzdk5/mhamzdk5.cpp"
                },
                "region": {
                  "startLine": 515,
                  "startColumn": 2,
                  "endLine": 515,
                  "endColumn": 45,
                  "charOffset": 19169,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, a_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhamzdk5/mhamzdk5.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19169,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  a_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5fca0e49-3ce6-48ed-b291-d5da596e9443",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mhamzdk5/mhamzdk5.cpp"
                },
                "region": {
                  "startLine": 569,
                  "startColumn": 2,
                  "endLine": 570,
                  "endColumn": 49,
                  "charOffset": 21337,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mhamzdk5/mhamzdk5.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21337,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map, \n         c_shape_[0] * c_shape_[1] * sizeof(OutT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-88477908-a88a-4594-acb7-4d366c95fc7c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/maskedsoftmax/maskedsoftmax.cpp"
                },
                "region": {
                  "startLine": 458,
                  "startColumn": 2,
                  "endLine": 458,
                  "endColumn": 67,
                  "charOffset": 21080,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map, operand_size_in_bytes_)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map, operand_size_in_bytes_)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map, operand_size_in_bytes_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/maskedsoftmax/maskedsoftmax.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21080,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map,  operand_size_in_bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b4d8fa81-0472-4572-a734-cd37b4f98672",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 13,
                  "endLine": 330,
                  "endColumn": 47,
                  "charOffset": 12427,
                  "charLength": 112,
                  "snippet": {
                    "text": "memcpy(&combined_data[base_offset], &wts_int16[wts_base_offset],\n                    wts_dim3 * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&combined_data[base_offset], &wts_int16[wts_base_offset],\n                    wts_dim3 * sizeof(uint16_t)",
                      "markdown": "`memcpy(&combined_data[base_offset], &wts_int16[wts_base_offset],\n                    wts_dim3 * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmatmulbias/mladfmatmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12427,
                        "charLength": 112
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&combined_data[base_offset], <size of &combined_data[base_offset]>,  &wts_int16[wts_base_offset], \n                    wts_dim3 * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fa94e480-fb93-4e08-8a02-340573277a53",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/maskedsoftmax/maskedsoftmax.cpp"
                },
                "region": {
                  "startLine": 426,
                  "startColumn": 2,
                  "endLine": 426,
                  "endColumn": 58,
                  "charOffset": 19785,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy((void *)b_bo_map, (void *)b, mask_size_in_bytes_)",
                    "rendered": {
                      "text": "memcpy((void *)b_bo_map, (void *)b, mask_size_in_bytes_)",
                      "markdown": "`memcpy((void *)b_bo_map, (void *)b, mask_size_in_bytes_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/maskedsoftmax/maskedsoftmax.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19785,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)b_bo_map, <size of (void *)b_bo_map>,  (void *)b,  mask_size_in_bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f39087f6-eed3-42db-b945-db8700554d35",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/maskedsoftmax/maskedsoftmax.cpp"
                },
                "region": {
                  "startLine": 410,
                  "startColumn": 2,
                  "endLine": 410,
                  "endColumn": 61,
                  "charOffset": 19171,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes_)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes_)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/maskedsoftmax/maskedsoftmax.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19171,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  operand_size_in_bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b9db5897-5bd8-41ee-abc2-4abc7e479596",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                },
                "region": {
                  "startLine": 547,
                  "startColumn": 2,
                  "endLine": 548,
                  "endColumn": 49,
                  "charOffset": 20446,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20446,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map, \n         c_shape_[0] * c_shape_[1] * sizeof(OutT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eb19200d-77ed-4dea-a616-4b224457ad4a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                },
                "region": {
                  "startLine": 499,
                  "startColumn": 2,
                  "endLine": 499,
                  "endColumn": 45,
                  "charOffset": 18466,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, a_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18466,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  a_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-72c62076-44e5-4a09-80dd-15b97b2f468a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                },
                "region": {
                  "startLine": 484,
                  "startColumn": 2,
                  "endLine": 484,
                  "endColumn": 57,
                  "charOffset": 17881,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy((void *)param_bo_map, (void *)param, param_size)",
                    "rendered": {
                      "text": "memcpy((void *)param_bo_map, (void *)param, param_size)",
                      "markdown": "`memcpy((void *)param_bo_map, (void *)param, param_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17881,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)param_bo_map, <size of (void *)param_bo_map>,  (void *)param,  param_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6967650f-7d52-4f9c-8de8-9784d6f6fd8f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                },
                "region": {
                  "startLine": 369,
                  "startColumn": 2,
                  "endLine": 369,
                  "endColumn": 43,
                  "charOffset": 13672,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(params.data(), kernel_params_, 64)",
                    "rendered": {
                      "text": "memcpy(params.data(), kernel_params_, 64)",
                      "markdown": "`memcpy(params.data(), kernel_params_, 64)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13672,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(params.data(), <size of params.data()>,  kernel_params_,  64)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fcceabe5-5ac2-44c4-ac43-71911cdd17b3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                },
                "region": {
                  "startLine": 360,
                  "startColumn": 2,
                  "endLine": 360,
                  "endColumn": 58,
                  "charOffset": 13315,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(kernel_params_, kernel_params.data, params_bytes)",
                    "rendered": {
                      "text": "memcpy(kernel_params_, kernel_params.data, params_bytes)",
                      "markdown": "`memcpy(kernel_params_, kernel_params.data, params_bytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmul_a16w8_mladf/matmul_a16w8_mladf.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13315,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(kernel_params_, <size of kernel_params_>,  kernel_params.data,  params_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-43424f90-4625-4884-901f-c9b5e8127e3d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/record_timer/record_timer.cpp"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 2,
                  "endLine": 71,
                  "endColumn": 51,
                  "charOffset": 2704,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy((void *)txn.data(), (void *)txn_ptr, size)",
                    "rendered": {
                      "text": "memcpy((void *)txn.data(), (void *)txn_ptr, size)",
                      "markdown": "`memcpy((void *)txn.data(), (void *)txn_ptr, size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/record_timer/record_timer.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2704,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)txn.data(), <size of (void *)txn.data()>,  (void *)txn_ptr,  size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-792edf2f-d5d8-495e-9df5-dde3e4e0c24e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/a16w8_matrix.hpp"
                },
                "region": {
                  "startLine": 160,
                  "startColumn": 22,
                  "endLine": 160,
                  "endColumn": 30,
                  "charOffset": 5037,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-131d7be7-d023-46c2-ab47-fd79180c342f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/a16w8_matrix.hpp"
                },
                "region": {
                  "startLine": 160,
                  "startColumn": 22,
                  "endLine": 160,
                  "endColumn": 27,
                  "charOffset": 5037,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-11103575-c7d4-42ec-a045-ccad8a2458fa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmulbias/matmulbias.cpp"
                },
                "region": {
                  "startLine": 417,
                  "startColumn": 2,
                  "endLine": 418,
                  "endColumn": 49,
                  "charOffset": 15662,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmulbias/matmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15662,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map, \n         c_shape_[0] * c_shape_[1] * sizeof(OutT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-77ac4e0c-2e35-464b-8463-d435e9684787",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/matmulbias/matmulbias.cpp"
                },
                "region": {
                  "startLine": 370,
                  "startColumn": 2,
                  "endLine": 370,
                  "endColumn": 45,
                  "charOffset": 13662,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, a_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/matmulbias/matmulbias.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13662,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  a_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b186afab-c3a5-46d4-86d1-c17e8eaa45e7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/gprb_validation.cpp"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 22,
                  "endLine": 39,
                  "endColumn": 30,
                  "charOffset": 1593,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-c447fcf9-745b-42d9-98f8-ceb79ea17e58",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/gprb_validation.cpp"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 22,
                  "endLine": 39,
                  "endColumn": 27,
                  "charOffset": 1593,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-002590e0-ee72-4e8d-ae14-0551a80ed1c2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/silu_qdq/silu_qdq.cpp"
                },
                "region": {
                  "startLine": 674,
                  "startColumn": 2,
                  "endLine": 675,
                  "endColumn": 49,
                  "charOffset": 26336,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/silu_qdq/silu_qdq.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26336,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map, \n         c_shape_[0] * c_shape_[1] * sizeof(OutT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5f644c68-9341-42b9-93cd-d47ff0ddedc5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/silu_qdq/silu_qdq.cpp"
                },
                "region": {
                  "startLine": 631,
                  "startColumn": 2,
                  "endLine": 631,
                  "endColumn": 45,
                  "charOffset": 24652,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, a_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/silu_qdq/silu_qdq.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24652,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  a_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4e1321e0-e9d2-4bd7-8cf5-8dfd2ed0785f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/matmulnbits_pack_const.hpp"
                },
                "region": {
                  "startLine": 149,
                  "startColumn": 7,
                  "endLine": 149,
                  "endColumn": 62,
                  "charOffset": 5640,
                  "charLength": 55,
                  "snippet": {
                    "text": "memcpy(out_array, const_vecs.at(0).data(), total_bytes)",
                    "rendered": {
                      "text": "memcpy(out_array, const_vecs.at(0).data(), total_bytes)",
                      "markdown": "`memcpy(out_array, const_vecs.at(0).data(), total_bytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/ops_common/matmulnbits_pack_const.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5640,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_array, <size of out_array>,  const_vecs.at(0).data(),  total_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-32a63d15-2fd7-45e8-8f7c-48fe8f5cdb1f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmharope/mladfmharope.cpp"
                },
                "region": {
                  "startLine": 569,
                  "startColumn": 2,
                  "endLine": 569,
                  "endColumn": 61,
                  "charOffset": 27612,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes_)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes_)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmharope/mladfmharope.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27612,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  operand_size_in_bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2237b812-5e0e-420f-8229-f769030866c9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmharope/mladfmharope.cpp"
                },
                "region": {
                  "startLine": 612,
                  "startColumn": 2,
                  "endLine": 612,
                  "endColumn": 67,
                  "charOffset": 29210,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map, operand_size_in_bytes_)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map, operand_size_in_bytes_)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map, operand_size_in_bytes_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmharope/mladfmharope.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29210,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map,  operand_size_in_bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9195a6fd-ea53-4ec1-9294-90f2a21ec22b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/sfmx_util.cpp"
                },
                "region": {
                  "startLine": 241,
                  "startColumn": 8,
                  "endLine": 241,
                  "endColumn": 14,
                  "charOffset": 8805,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4bc45186-5282-4aa8-a105-430dd05cc079",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/sfmx_util.cpp"
                },
                "region": {
                  "startLine": 262,
                  "startColumn": 8,
                  "endLine": 262,
                  "endColumn": 14,
                  "charOffset": 9666,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e5a2f3b9-8596-4fa8-a9c2-cfecd87082f2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/sfmx_util.cpp"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 8,
                  "endLine": 229,
                  "endColumn": 14,
                  "charOffset": 8397,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1f8a4c81-14e6-41e3-8d98-5a6a239a694f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/sfmx_util.cpp"
                },
                "region": {
                  "startLine": 221,
                  "startColumn": 6,
                  "endLine": 221,
                  "endColumn": 12,
                  "charOffset": 8085,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e2454a0b-20ca-4925-8c1a-ecc8c440f358",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/utils/tmpfile.cpp"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 15,
                  "endLine": 32,
                  "endColumn": 20,
                  "charOffset": 846,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8591619b-5364-436c-8e80-16b396f75e2f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/sfmx_util.cpp"
                },
                "region": {
                  "startLine": 180,
                  "startColumn": 4,
                  "endLine": 180,
                  "endColumn": 10,
                  "charOffset": 6522,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cfe712a0-ece1-49de-90f8-309255ad0938",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/sfmx_util.cpp"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 4,
                  "endLine": 177,
                  "endColumn": 10,
                  "charOffset": 6471,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-25158d96-3118-4c4d-9f1c-0b299d40a951",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/sfmx_util.cpp"
                },
                "region": {
                  "startLine": 175,
                  "startColumn": 4,
                  "endLine": 175,
                  "endColumn": 10,
                  "charOffset": 6425,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-af6e983e-f205-46a4-84c4-1e762206b493",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/sfmx_util.cpp"
                },
                "region": {
                  "startLine": 174,
                  "startColumn": 4,
                  "endLine": 174,
                  "endColumn": 10,
                  "charOffset": 6383,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-74d687b5-d1a2-4cf4-90f3-9f4a5efefc8d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/mladfmharope/mladfmharope.cpp"
                },
                "region": {
                  "startLine": 582,
                  "startColumn": 2,
                  "endLine": 582,
                  "endColumn": 58,
                  "charOffset": 28101,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy((void *)b_bo_map, (void *)b, trig_size_in_bytes_)",
                    "rendered": {
                      "text": "memcpy((void *)b_bo_map, (void *)b, trig_size_in_bytes_)",
                      "markdown": "`memcpy((void *)b_bo_map, (void *)b, trig_size_in_bytes_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/mladfmharope/mladfmharope.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28101,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)b_bo_map, <size of (void *)b_bo_map>,  (void *)b,  trig_size_in_bytes_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1770e82f-c3f6-4628-bda8-4918bf8a0756",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/l2_norm/l2_norm.cpp"
                },
                "region": {
                  "startLine": 625,
                  "startColumn": 2,
                  "endLine": 626,
                  "endColumn": 49,
                  "charOffset": 24371,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/l2_norm/l2_norm.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24371,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map, \n         c_shape_[0] * c_shape_[1] * sizeof(OutT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7ca4a441-6942-4997-931c-33456f9da4d1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/l2_norm/l2_norm.cpp"
                },
                "region": {
                  "startLine": 582,
                  "startColumn": 2,
                  "endLine": 582,
                  "endColumn": 45,
                  "charOffset": 22687,
                  "charLength": 43,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, a_size)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, a_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/l2_norm/l2_norm.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22687,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  a_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-434c4519-776c-4093-88b7-c8223dce7639",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/silu/silu.cpp"
                },
                "region": {
                  "startLine": 393,
                  "startColumn": 2,
                  "endLine": 393,
                  "endColumn": 66,
                  "charOffset": 14183,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map, operand_size_in_bytes)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map, operand_size_in_bytes)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map, operand_size_in_bytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/silu/silu.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14183,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map,  operand_size_in_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c9d29fa5-3261-4df6-9fe8-22bf9d6a42db",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 418,
                  "startColumn": 53,
                  "endLine": 418,
                  "endColumn": 61,
                  "charOffset": 13765,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-11e3ced3-bdc7-4c5c-ba2b-673f17fcc7e4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 412,
                  "startColumn": 10,
                  "endLine": 412,
                  "endColumn": 15,
                  "charOffset": 13618,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-f8acb37b-510a-4cd7-beca-ce20a7a16b8b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 418,
                  "startColumn": 53,
                  "endLine": 418,
                  "endColumn": 58,
                  "charOffset": 13765,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-afcefff5-6d31-4a9a-877f-3d903b4d3b02",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 412,
                  "startColumn": 10,
                  "endLine": 412,
                  "endColumn": 18,
                  "charOffset": 13618,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-6bdab580-a758-49c2-8b97-242821d6d7d9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/silu/silu.cpp"
                },
                "region": {
                  "startLine": 365,
                  "startColumn": 2,
                  "endLine": 365,
                  "endColumn": 60,
                  "charOffset": 13124,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes)",
                    "rendered": {
                      "text": "memcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes)",
                      "markdown": "`memcpy((void *)a_bo_map, (void *)a, operand_size_in_bytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/silu/silu.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13124,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)a_bo_map, <size of (void *)a_bo_map>,  (void *)a,  operand_size_in_bytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6c5a30b0-a362-4c57-ae92-3d720ca74139",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 293,
                  "startColumn": 6,
                  "endLine": 293,
                  "endColumn": 59,
                  "charOffset": 10102,
                  "charLength": 53,
                  "snippet": {
                    "text": "memcpy(&float16_vec, in, remainder * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&float16_vec, in, remainder * sizeof(uint16_t)",
                      "markdown": "`memcpy(&float16_vec, in, remainder * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/ops_common/dtype_utils.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10102,
                        "charLength": 53
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&float16_vec, <size of &float16_vec>,  in,  remainder * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b4af3b7c-9dec-454d-bc90-fa65615b6436",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 342,
                  "startColumn": 6,
                  "endLine": 342,
                  "endColumn": 60,
                  "charOffset": 12046,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(out, &float16_vec, remainder * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(out, &float16_vec, remainder * sizeof(uint16_t)",
                      "markdown": "`memcpy(out, &float16_vec, remainder * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/ops_common/dtype_utils.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12046,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &float16_vec,  remainder * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-790e0f02-e8c8-4734-bf77-a8b0a5aa9dd7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 337,
                  "startColumn": 6,
                  "endLine": 337,
                  "endColumn": 60,
                  "charOffset": 11769,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(&bfloat16_vec, in, remainder * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&bfloat16_vec, in, remainder * sizeof(uint16_t)",
                      "markdown": "`memcpy(&bfloat16_vec, in, remainder * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/ops_common/dtype_utils.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11769,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&bfloat16_vec, <size of &bfloat16_vec>,  in,  remainder * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bd2a1887-5351-4d6f-bc8f-ecb7f5892d68",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 199,
                  "startColumn": 45,
                  "endLine": 199,
                  "endColumn": 53,
                  "charOffset": 6709,
                  "charLength": 8,
                  "snippet": {
                    "text": "RAND_MAX",
                    "rendered": {
                      "text": "RAND_MAX",
                      "markdown": "`RAND_MAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-2b99122f-f021-471e-a25e-ba554f9cee04",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Do not use weak/non-cryptographic random number generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 199,
                  "startColumn": 29,
                  "endLine": 199,
                  "endColumn": 34,
                  "charOffset": 6693,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d1191486-ad49-464b-9d13-be745e8b9fba",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 180,
                  "startColumn": 7,
                  "endLine": 180,
                  "endColumn": 44,
                  "charOffset": 6182,
                  "charLength": 37,
                  "snippet": {
                    "text": "memcpy(&dst[2], src, sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&dst[2], src, sizeof(uint16_t)",
                      "markdown": "`memcpy(&dst[2], src, sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/ops_common/dtype_utils.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6182,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&dst[2], <size of &dst[2]>,  src,  sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-79855bf1-d3b4-45fd-92b9-94281708cf4c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 296,
                  "startColumn": 6,
                  "endLine": 296,
                  "endColumn": 57,
                  "charOffset": 10281,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(out, &bf16_vec, remainder * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(out, &bf16_vec, remainder * sizeof(uint16_t)",
                      "markdown": "`memcpy(out, &bf16_vec, remainder * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/ops_common/dtype_utils.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10281,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out, <size of out>,  &bf16_vec,  remainder * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-19f3b614-a39c-42f1-ba5f-3b1c9ded06df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/slice/slice.cpp"
                },
                "region": {
                  "startLine": 455,
                  "startColumn": 2,
                  "endLine": 456,
                  "endColumn": 49,
                  "charOffset": 17027,
                  "charLength": 91,
                  "snippet": {
                    "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                    "rendered": {
                      "text": "memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)",
                      "markdown": "`memcpy((void *)aie_out, (void *)c_bo_map,\n         c_shape_[0] * c_shape_[1] * sizeof(OutT)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/slice/slice.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17027,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "memcpy_s((void *)aie_out, <size of (void *)aie_out>,  (void *)c_bo_map, \n         c_shape_[0] * c_shape_[1] * sizeof(OutT)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1d3a03a9-4c0d-4b25-9d59-abb07cfb66db",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ops/ops_common/dtype_utils.h"
                },
                "region": {
                  "startLine": 242,
                  "startColumn": 6,
                  "endLine": 242,
                  "endColumn": 60,
                  "charOffset": 8266,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(&bfloat16_vec, in, remainder * sizeof(uint16_t)",
                    "rendered": {
                      "text": "memcpy(&bfloat16_vec, in, remainder * sizeof(uint16_t)",
                      "markdown": "`memcpy(&bfloat16_vec, in, remainder * sizeof(uint16_t)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ops/ops_common/dtype_utils.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8266,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&bfloat16_vec, <size of &bfloat16_vec>,  in,  remainder * sizeof(uint16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}